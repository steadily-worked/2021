# 자료구조

## 추상 자료형 (Abstract Data Type)

### 기능 vs 구현

삽입 연산(insert operation)의 기능과 구현?

기능: 연산이 "무엇을" 하는지에 관한 내용.

- 삽입 연산의 기능: "순서 데이터에서 원하는 위치에 데이터를 저장"

구현: 기능을 "어떻게" 하는지에 관한 내용

- 링크드 리스트와 동적 배열 등에서 삽입을 하는 방법은 각각 달랐다.

### 추상화

```python
def insert(data_type, index, element):
    """자료형 data_type의 위치 index에 데이터 element를 삽입해주는 함수""" # 함수의 기능만 알아도 사용할 수 있음 -> 추상화를 했음
```

#### 추상 자료형

- 자료 구조를 추상화한 것

- 데이터를 저장 / 사용할 때 기능만 생각

### 추상 자료형 vs 자료 구조

1. 리스트 (추상 자료형)

- 데이터간 순서 관계를 유지할 수 있다.

  - 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
  - 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다.
  - 삽입 연산: 특정 위치에 새로운 데이터를 저장한다.
  - 삭제 연산: 특정 위치에 있는 데이터를 지운다.

- 연산의 "기능들"만 갖고 있음. 구현 과정은 포함되어있지 않음.

2. 동적 배열 (자료 구조)

- 데이터를 메모리에 순서대로, 그리고 연속적으로 저장한다.

  - 접근 연산: 인덱스 주소를 한 번에 계산해서 메모리에 접근한다.
  - 탐색 연산: 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다.
  - 삽입 연산: 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다.
  - 삭제 연산: 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다.

- 데이터를 어떻게 저장할 건지, 데이터를 어떻게 유지할 건지, 각 연산을 구체적으로 어떻게 할 지를 묶어둔 개념이다.

<img width="812" alt="스크린샷 2021-02-13 오후 1 30 33" src="https://user-images.githubusercontent.com/61453718/107841610-a8bd5300-6dff-11eb-8622-c0c71701c903.png">

리스트라는 추상 자료형을 동적 배열이라는 자료 구조로 구현할 수도 있고, 링크드 리스트라는 자료구조로 구현할 수도 있다.

프로그래밍을 할 때 자료 구조보다 추상 자료형을 떠올리는 게 더 편하다.

- 데이터를 메모리에 순서대로 저장하고 바꾸고 싶다. (기능)

  - 추상 자료형을 생각한다면,
    - 구현에 대해 생각할 필요가 없으므로 리스트를 사용해서 이 위치에 데이터를 저장해야겠다고 생각하면 편하다.
  - 자료 구조를 생각한다면,

  ```
  동적 배열을 쓰면 메모리에 데이터를 연속적이고 순차적으로 저장해서...
  새로운 위치에 데이터를 저장하려면 모든 데이터를 뒤로 밀고 새로 생겨난 자리에...
  아니면 링크드 리스트를 써서...
  ```

  이렇게 하나하나 과정을 생각하다보면 상당히 복잡해질 수 있다.

- 결국, 추상 자료형을 생각한다면 코드의 흐름에 집중할 수 있게 되는 것이다.

### 리스트(list)

- 데이터간 순서 관계를 유지할 수 있다.

  - 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
  - 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다.
  - 삽입 연산: 특정 위치에 새로운 데이터를 저장한다.
  - 삭제 연산: 특정 위치에 있는 데이터를 지운다.

- 파이썬
  - 추상화가 많이 된 고수준 언어
  - 많은 자료형 이름이 추상 자료형이다.
    - 파이썬 자료형 list -> 구현을 몰라도 기능만 알고 사용할 수 있음

```python
# 파이썬 리스트 생성
trending = []

# 특정 위치에 데이터 삽입
trending.insert(0, "연예인 A씨")
trending.insert(1, "잠실 콘서트")
trending.insert(2, "한국 휴일 수")
trending.insert(3, "추석 음식")

print(trending) # 리스트 출력

# 괄호를 이용한 인덱스 접근
print(trending[0])
print(trending[1])

trending[2] = 4

print(trending)

# in을 이용한 탐색
print("연예인 A씨" in trending)
print("연예인 B씨" in trending)

# del을 이용한 삭제
del trending[0]

print(trending)
```

결과

```
['연예인 A씨', '잠실 콘서트', '한국 휴일 수', '추석 음식']
연예인 A씨
잠실 콘서트
['연예인 A씨', '잠실 콘서트', 4, '추석 음식']
True
False
['잠실 콘서트', 4, '추석 음식']
```

#### 리스트 구현

|             | 동적 배열        | 더블리 링크드 리스트 |
| ----------- | ---------------- | -------------------- |
| 접근        | `O(1)`           | `O(n)`               |
| 탐색        | `O(n)`           | `O(n)`               |
| 접근 + 삽입 | `O(n)`           | `O(n)`               |
| 접근 + 삭제 | `O(n)`           | `O(n)`               |
|             |                  |                      |
| 맨 앞 삽입  | `O(n)`           | `O(1)`               |
| 맨 앞 삭제  | `O(n)`           | `O(1)`               |
| 맨 뒤 삽입  | 분할 상환 `O(1)` | `O(1)`               |
| 맨 뒤 삭제  | 분할 상환 `O(1)` | `O(1)`               |

동적 배열은 데이터를 수정하거나 가져오는 접근 연산, 그리고 맨 끝에 데이터를 삽입, 삭제하는 연산을 효율적으로 할 수 있고, 링크드 리스트는 처음과 끝에 데이터를 삽입, 삭제하는 연산을 효율적으로 할 수 있다. 리스트에서는 어떤 걸 써야될까?

- 각 리스트에서 많이 사용할 연산에 대한 시간 복잡도를 비교해보면 된다.

1. 접근: 동적 배열의 접근 연산이 더 효율적 -> 동적 배열을 사용
2. 가장 앞에 데이터 삽입: 링크드 리스트가 더 효율적 -> 링크드 리스트를 사용

### 큐(Queue)

- FIFO(First In First Out)의 형태를 취한다. 앞에서만 삭제하고 뒤에서만 삽입한다.

  - 가장 먼저 들어온 데이터가 가장 먼저 삭제된다.

- 데이터간 순서 관계를 유지할 수 있다.

  - 맨 뒤 데이터 추가
  - 맨 앞 데이터 삭제
  - 맨 앞 데이터 접근

- 파이썬에서 `deque`(Doubly-ended-que: 양면 큐)를 import해와서 쓸 수 있다.
  - 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형이다.

```python
# deque는 Python의 collections 모듈에서 갖고온다.
from collections import deque

queue = deque()

# 큐의 맨 끝에 데이터 삽입
queue.append("태호")
queue.append("현승")
queue.append("지웅")
queue.append("동욱")
queue.append("신의")

print(queue) # 큐 출력

# 큐의 가장 앞 데이터에 접근
print(queue[0])

# 큐의 맨 앞 데이터 삭제
print(queue.popleft()) # popleft는 삭제한 데이터를 리턴하기도 한다.
print(queue.popleft())
print(queue.popleft())

print(queue)
```

결과

```
deque(['태호', '현승', '지웅', '동욱', '신의'])
태호
태호
현승
지웅
deque(['동욱', '신의'])
```

#### 큐 구현

리스트와 마찬가지로 큐 또한 동적 배열, 링크드 리스트로 구현할 수 있다.

|            | 동적 배열        | 더블리 링크드 리스트 |
| ---------- | ---------------- | -------------------- |
| 맨 앞 삭제 | `O(n)`           | `O(1)`               |
| 맨 뒤 삽입 | 분할 상환 `O(1)` | `O(1)`               |
| 맨 앞 접근 | `O(1)`           | `O(1)`               |

삭제의 경우 동적 배열보다 링크드 리스트의 시간 복잡도가 덜하므로 큐의 경우는 링크드 리스트를 쓰는 것이 더 효율적이다. Python의 `deque` 또한 더블리 링크드 리스트로 구현되어 있다.

### 스택(Stack)

스택은 항상 맨 끝에 추가하고, 삭제할 때도 맨 끝에 삭제한다.
LIFO: Last-In-First-Out (가장 마지막에 들어온 데이터가 가장 먼저 삭제된다.)

- 데이터간 순서 관계를 유지할 수 있다.

  - 맨 뒤 데이터 추가
  - 맨 뒤 데이터 삭제
  - 맨 뒤 데이터 접근

- Python에서 스택의 이름을 갖는 자료형은 없으나, 대신 큐를 사용할 때와 똑같이 `deque`를 이용해서 스택 연산을 할 수 있다.
  - 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형이다.

```python
from collection import deque

stack = deque() # stack = [] 이렇게 빈 리스트를 써도 똑같이 효율적으로 스택을 사용할 수 있다.

# 스택 맨 끝에 데이터 추가
stack.append("T")
stack.append("a")
stack.append("e")
stack.append("h")
stack.append("o")

print(stack) # 스택 출력

# 스택 맨 끝 데이터 접근
print(stack[-1])

# 스택 맨 끝 데이터 삭제
print(stack.pop())
print(stack.pop())
print(stack.pop())

print(stack) # 스택 출력
```

결과

```
deque(['T', 'a', 'e', 'h', 'o'])
o
o
h
e
deque(['T', 'a'])
```

#### 스택 구현

스택 또한 동적 배열과 링크드 리스트를 이용해서 구현할 수 있다.

|            | 동적 배열        | 더블리 링크드 리스트 |
| ---------- | ---------------- | -------------------- |
| 맨 뒤 삭제 | 분할 상환 `O(1)` | `O(1)`               |
| 맨 뒤 삽입 | 분할 상환 `O(1)` | `O(1)`               |
| 맨 앞 접근 | `O(1)`           | `O(1)`               |

시간 상으로는 동적 배열이나 링크드 리스트나 시간 복잡도가 동일해서 어떤 것을 사용하든 상관이 없다.

### 딕셔너리(Dictionary)

- 데이터간 순서 관계를 약속하지 않음

  - `key`-`value` 데이터 쌍 삽입
  - `key`를 이용한 데이터 탐색
  - `key`를 이용한 데이터 삭제

```python
grades = {}

# key - value 데이터 삽입
grades['현승'] = 80
grades['태호'] = 60
grades['영훈'] = 90
grades['지웅'] = 70
grades['동욱'] = 96

print(grades) # 딕셔너리 출력

# 한 key에 여러 value 저장 시도
grades['태호'] = 100

print(grades)

# key를 이용해서 value 탐색
print(grades['동욱'])
print(grades['현승'])

# key를 이용한 삭제
grades.pop("태호")
grades.pop("지웅") # 지우는 data 쌍의 value 리턴

print(grades) # 딕셔너리 출력
```

결과

```python
{'현승': 80, '태호': 60, '영훈': 90, '지웅': 70, '동욱': 96}
{'현승': 80, '태호': 100, '영훈': 90, '지웅': 70, '동욱': 96} # 새로운 value 저장 시 덮어씌움
96
80
{'현승': 80, '영훈': 90, '동욱': 96}
```

### 세트(set)

- 데이터간 순서 관계를 약속하지 않음

  - 삽입: 데이터를 저장할 수 있다. (중복 데이터 X)
  - 탐색: 데이터가 저장됐는지 확인할 수 있다.
  - 삭제: 저장한 데이터를 지울 수 있다.

```python
finished_class = set()

# 데이터 저장
finished_class.add("자료 구조")
finished_class.add("알고리즘")
finished_class.add("프로그래밍 기초")
finished_class.add("인터랙티브 웹")
finished_class.add("데이터 사이언스")

print(finished_classes) # 세트 출력

# 중복 데이터 저장 시도
finished_class.add("자료 구조")
finished_class.add("알고리즘")

print(finished_classes) # 세트 출력

# 데이터 탐색
print("컴퓨터 개론" in finished_class)
print("자료 구조" in finished_class)

# 데이터 삭제
finished_class.remove("자료 구조")
finished_class.remove("알고리즘")

print(finished_class)
```

결과

```python
{'자료 구조', '데이터 사이언스', '인터랙티브 웹', '알고리즘', '프로그래밍 기초'}
{'자료 구조', '데이터 사이언스', '인터랙티브 웹', '알고리즘', '프로그래밍 기초'} # 변화 X. 똑같은 데이터는 저장되지 않음
False
True
{'데이터 사이언스', '인터랙티브 웹', '프로그래밍 기초'}
```

#### 세트 구현

- 인덱스에 key만 저장한다. -> 그래도 탐색과 삭제 연산에 무리가 없다.

### 파이썬 자료형 주요 시간 복잡도 정리

시간 복잡도를 바탕으로 파이썬 자료형들을 사용할 때 얼마나 효율적으로 하는지를 생각해볼 수 있다.

##### 리스트 (동적 배열)

| 연산       | 예시                             | 시간 복잡도       |
| ---------- | -------------------------------- | ----------------- |
| 접근       | `list_1[0]`, `list_1[0] = 5`     | `O(1)`            |
| 추가       | `list_1.append(2)`               | `O(1)`(분할 상환) |
| 맨 뒤 삭제 | `list_1.pop()`                   | `O(1)`(분할 상환) |
| 길이 확인  | `len(list_1)`                    | `O(1)`            |
| 삽입       | `list_1.insert(3, "성태호"))`    | `O(n)`            |
| 삭제       | `del list_1[0]`, `list_1.pop(3)` | `O(n)`            |
| 탐색       | `"이제하" in list_1`             | `O(n)`            |

##### deque (더블리 링크드 리스트)

| 연산       | 예시                           | 시간 복잡도 |
| ---------- | ------------------------------ | ----------- |
| 맨 앞 삭제 | `deque_1.popleft()`            | `O(1)`      |
| 맨 앞 삽입 | `deque_1.appendleft("김신의")` | `O(1)`      |
| 맨 뒤 삭제 | `deque_1.pop()`                | `O(1)`      |
| 맨 뒤 삽입 | `deque_1.append("이규식")`     | `O(1)`      |
| 길이 확인  | `len(deque_1)`                 | `O(1)`      |

##### 딕셔너리 (해시 테이블)

| 연산      | 예시                                           | 시간 복잡도  |
| --------- | ---------------------------------------------- | ------------ |
| 탐색      | `dict_1['성태호']`                             | `O(1)`(평균) |
| 삽입      | `dict_1['강영훈'] = 100`                       | `O(1)`(평균) |
| 삭제      | `del dict_1['강영훈']`, `dict_1.pop("강영훈")` | `O(1)`(평균) |
| 길이 확인 | `len(dict_1)`                                  | `O(1)`       |

##### 세트 (해시 테이블)

| 연산      | 예시                                            | 시간 복잡도  |
| --------- | ----------------------------------------------- | ------------ |
| 탐색      | `"최지웅" in set_1`                             | `O(1)`(평균) |
| 삽입      | `set_1.add("손동욱")`                           | `O(1)`(평균) |
| 삭제      | `se1_1.remove("김현승")`, `set_1.pop("김현승")` | `O(1)`(평균) |
| 길이 확인 | `len(set_1)`                                    | `O(1)`       |

### 파이썬 자료형 잘 고르기

#### 리스트

파이썬 리스트는 굉장히 활용 범위가 큰 자료이다. 프로그래밍을 할 때 사실상 리스트만 사용하면 대부분의 경우 필요한 기능을 모두 사용할 수 있다. 사용 가능 범위가 넓다 보니까 어떤 다른 자료형을 사용할지 생각하지 않고 바로 리스트를 사용해 버리는 경우가 많다. 무조건 리스트를 사용해버리면 효율적으로 프로그래밍을 하기 힘들다.

##### 바로 리스트를 사용할 때

여러 개의 데이터(정확히는 0부터 999999까지의 정수)를 저장한 후, 특정 데이터를 탐색하는 코드를 써볼 것이다. 대부분의 상황과 비슷하게 동적 배열로 구현돼 있는 파이썬 리스트를 사용하면 원하는 코드를 쓸 수 있다.

```python
# 예시를 위해 사용할 모듈 import
import time

# 데이터를 리스트에 저장
test_list = [x for x in range(0, 1000000)]

# 특정 항목이 리스트에 있는지 확인할 때 걸리는 시간 파악
t_0 = time.time()
999999 in test_list # 리스트 탐색
t_1 = time.time()

print(f"리스트에서 특정 항목을 찾는데 걸린 시간: {t_1 - t_0}")
```

먼저 파이썬 리스트에 0부터 999999까지의 정수 데이터를 저장했다. 딱히 순서 데이터가 필요한 건 아닌데, 그냥 구체적으로 어떤 연산이 필요한지 생각하지 않고 생각해내기 가장 쉬운 리스트를 사용한 것이다. 여기 999999가 저장되었는지 키워드 `in`을 사용해서 확인을 해봤다. 특정 데이터가 자료형 안에 있는지 탐색을 하는 것이다. 이 때 파이썬의 `time` 모듈을 이용해서 시작할 때의 시간과 코드가 끝날 때의 시간을 받아올 것이다. 두 시간의 차이는 탐색 코드가 실행되는데 걸리는 시간과 같다.

`리스트에서 특정 항목을 찾는데 걸린 시간: 0.013087987899780273`

시간이 0.013초 정도 걸린다.

##### 구체적으로 어떤 기능이 필요한지 생각해서 세트를 쓰는 경우

정확히 똑같은 기능을 파이썬 리스트가 아닌 세트를 통해서 해볼 것이다.

```python

# 예시를 위해 사용할 모듈 import
import time

# 데이터를 set에 저장한다
test_set = set([x for x in range(0, 1000000)])

# 특정 항목이 set에 있는지 확인할 때 걸리는 시간 파악
t_0 = time.time()
999999 in test_set
t_1 = time.time()

print(f"세트에서 특정 항목을 찾는데 걸린 시간: {t_1 - t_0}")
```

코드를 돌려보면

`set에서 특정 항목을 찾는데 걸린 시간: 3.0994415283203125e-06`

0.000000309초가 걸렸다.

#### 파이썬 리스트와 세트의 비교

0.013초와 0.000000309초.. 엄청 큰 차이가 아니라고 느껴질 수도 있다. 지금은 탐색 연산을 한 번만 하지만 보통 많은 프로그램들은 이 연산을 반복적으로 하는 경우가 대부분이다. 이 연산을 1000번 해야 된다고 하면 파이썬 리스트는 13초가 걸리지만 세트는 0.00309초가 걸린다. 이렇게 될 경우 차이가 엄청나다.

#### 파이썬 자료형을 잘 고른다는 것

자료형을 잘 고른다는 것은 현재 자신이 데이터에 하고 싶은 연산들이 뭐가 있고 얼마나 걸릴지에 대해서 잘 생각하는 것이다. 초급자의 수준을 넘어서기 위해선 파이썬 자료형 뒤에 가려진 자료 구조를 떠올릴 수 있어야 한다. 자료 구조를 떠올리면 각 연산의 시간 복잡도를 떠올릴 수 있기 때문이다.

위의 예시를 생각해보자. 리스트와 세트 모두 데이터를 저장할 수 있고, 저장한 데이터를 탐색할 수 있는 자료형이다. 근데 리스트는 동적 배열, 세트는 해시 테이블로 구현되어 있다.

| 시간 복잡도 | 파이썬 리스트(동적 배열) | 파이썬 세트(해시 테이블) |
| ----------- | ------------------------ | ------------------------ |
| 탐색 연산   | `O(n)`                   | `O(1)`                   |

위의 표에서처럼, 쓰고 싶은 연산의 시간 복잡도를 생각해낼 수 있어야 한다. 바로 이 차이가 위에서 본 리스트와 세트를 쓸 때의 시간 차이를 만든다.

세트뿐만 아니라 파이썬 `deque`를 쓸 때도 마찬가지다. 더블리 링크드 리스트 연산들의 시간 복잡도를 생각할 수 있어야 되고 이 시간 복잡도를 바탕으로 파이썬 리스트와 비교해서 어떤 자료형을 쓸지를 정할 수 있어야 된다.

### 결론

프로그램이 좋은 기능을 갖고 있고, 좋은 아이디어라고 한들 클릭을 했을 때 13초를 기다려야 된다면 사용하기 쉽지 않다. 반면 0.00309초면 일반 사람들은 느낄 수 없을 정도의 짧은 순간이다.

파이썬에서 어떤 자료형을 사용할 건지 잘 고르는 건 결국 어떤 자료 구조를 쓸 건지 고르는 것과 비슷하다. 데이터에 어떤 관계가 필요하고 어떤 기능들을 사용할 건지 잘 생각하면 더 효율적인 프로그램을 쓸 수 있다.

출처: [코드잇](https://codeit.kr)
