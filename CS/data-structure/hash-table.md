# 자료구조

순서가 없는 key-value 데이터. 하나의 key와 그 key에 해당하는 value를 저장하는 방법

### Direct Access Table

인덱스를 `key`로 생각하고 데이터를 저장

<img width="814" alt="스크린샷 2021-02-11 오후 4 30 02" src="https://user-images.githubusercontent.com/61453718/107611038-6b818580-6c86-11eb-858d-365e578f4545.png">

이 때, 예를 들어 101호에 누가 사는 지 알고 싶을 경우 인덱스 101에 접근하면 됨. `key`(인덱스)를 이용한 `value` 접근: O(1) 만큼의 시간 복잡도 소요

단 이 경우, 낭비되는 인덱스가 상당히 많다.

<img width="815" alt="스크린샷 2021-02-11 오후 4 33 26" src="https://user-images.githubusercontent.com/61453718/107611237-e185ec80-6c86-11eb-80b8-e99158abc3ee.png">

## 해시 테이블

해시 함수: 특정 값을 원하는 범위의 자연수로 바꿔주는 함수
ex) [101, 204, 302, 711, 942] -> (0~100사이 자연수로 바꿔주는 함수) -> [20, 30, 90, 5, 80]

<img width="817" alt="스크린샷 2021-02-11 오후 4 38 18" src="https://user-images.githubusercontent.com/61453718/107611535-8e606980-6c87-11eb-91f3-081f51e3ee8c.png">

원하는 인덱택에 기존 인덱스와 값을 저장한다. (`key` + `value`)

원하는 값을 불러오고 싶을 때는,

<img width="816" alt="스크린샷 2021-02-11 오후 4 40 33" src="https://user-images.githubusercontent.com/61453718/107611679-ded7c700-6c87-11eb-8e1f-d7e921744c07.png">

해시 함수에 711을 넣으면 30이 리턴된다. 그 후 배열에 인덱스 30에 접근하고, 저장된 값을 가져온다.

<b>해시 테이블(Hash Table)</b>

1. 고정된 크기의 배열을 만들고
2. 해시 함수를 이용해서 `key`를 원하는 범위의 자연수로 바꾼다.
3. 해시 함수 결과 값 인덱스에 `key-value` 쌍을 저장한다.

### 해시 함수의 조건

```
101호: 최지웅
204호: 강영훈
302호: 성태호
711호: 김현승
942호: 손동욱
```

1. 한 해시 테이블의 해시 함수는 결정론적이어야 한다.

- 똑같은 key를 넣었을 때는 항상 똑같은 결과가 나와야 한다는 것이다. 942를 해시 함수에 넣을 때 어쩔 때는 5가 나오고 어쩔 때는 10이 나오고 이러면 안된다는 것이다. 942를 넣으면 항상 똑같은 결과가 나와야 한다.

2. 결과 해시값이 치우치지 않고 고르게 나온다.

- 해시 함수에 101, 204, 302, 711, 942나 아무 숫자를 넣었을 때 항상 40만 나오면 안 된다는 것이다. 원하는 범위가 0~100의 자연수라면, 이 사이에 아무 두 숫자가 나올 확이 최대한 비슷해야 한다.

3. 빨리 계산할 수 있어야 한다.

- 해시 테이블은 모든 연산을 할 때마다 해시 함수를 써야 되는데, 해시 함수가 비효율적이면 해시 테이블도 비효율적일 수밖에 없다.

### 해시 함수를 만드는 두 가지 방법

#### 나누기 방법

가장 직관적이며 쉬운 방법임. 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 함수. 예를 들어 저장해야 되는 키가 40, 120, 788, 2307이고 배열 크기가 200이라고 해보자. 그럼 그냥 key를 200으로 나눠서 남는 나머지를 리턴한다는 것이다. 40을 넣으면 40, 120은 120, 788은 188, 2307은 107이 리턴된다.

```python
def hash_function_remainder(key, array_size):
    """해시 테이블의 key를 나누기 방법으로 `0 ~ array_size - 1` 범위의 자연수로 바꿔주는 함수"""
    return key % array_size

print(hash_function_remainder(40, 200))
print(hash_function_remainder(120, 200))
print(hash_function_remainder(788, 200))
print(hash_function_remainder(230, 200))
```

결과

```
40
120
188
107
```

어떤 키가 들어와도 `0 ~ 원하는 정수` 범위의 자연수로 바꿔준다.

#### 곱셈 방법

나누기 방법보다 살짝 더 까다롭다.

예시) `key`: 200, 배열 크기: 30

1. `0 < a < 1`인 아무 값 `a`를 정한다. 임의로 0.666이라고 하자.
2. 그다음에 `a`에 `key`를 곱한다. 0.666에 200을 곱하면 133.32가 되는데, 이 때 정수 부분은 버리고 소수 부분만 남긴다. 그렇게 되면 0.32가 남는다.
3. 마지막으로 남은 소수 부분에 배열의 크기를 곱해준다. 0.32 \* 30 하면 9.6이 된다. 이번엔 소수점 부분을 버리고 9만 남긴다.

왜 이 방법이 원하는 범위의 자연수를 리턴할까? `a`와 `key`를 곱한 값의 정수 부분을 버리면 그 결과 값은 `0.xxxx` 이런 식으로 0과 1 사이의 소수가 나올 수밖에 없다. 0과 1 사이의 소수에 테이블의 크기를 곱해버리면, 다시 0과 테이블 크기 사이의 수가 나온다. 0.0001에 테이블 크기 30을 곱하면 0.003이 나오고, 0.9999에 테이블 크기 30을 곱하면 29.997이 나온다. 항상 0보다 크거나 같고 테이블 크기인 30보단 작은 숫자가 나온다. 그리고 여기서 소수점 뒷자리를 버리므로 원하는 범위의 자연수를 구할 수 있다.

코드로 나타내면,

```python
def hash_function_multiplication(key, array_size, a):
    """해시 테이블의 key를 곱셈 방법으로 `0 ~ array_size - 1` 범위의 자연수로 바꿔주는 함수"""
    temp = a * key
    temp = temp - int(temp) # a와 key를 곱한 값의 소숫점 오른쪽 부분만 저장한다.

    return int(array_size * temp) # temp와 배열 크기를 곱한 수의 자연수 부분만 리턴한다.

print(hash_function_multiplication(40, 200, 0.61426212))
print(hash_function_multiplication(120, 200, 0.61426212))
print(hash_function_multiplication(788, 200, 0.61426212))
print(hash_function_multiplication(2307, 200, 0.61426212))
```

결과

```
114
142
7
20
```

정리

- 나눗셈: key % 배열의 크기
- 곱셈: `임의의 값 * key`의 소수 부분 \* `배열의 크기`를 한 후 소숫점 버림

### Python hash 함수

파이썬 언어도 내부적으로 `hash`라는 함수를 제공한다. 파이썬 해시 함수는 파라미터로 받은 값을 그냥 아무 정수로만 바꿔주는 함수이다. <b>특정 범위가 아닌, 아무 정수로만</b> 바꿔주는 것이다

```python
# 정수 값
print(hash(12345)) # 12345
print(hash(12345)) # 12345

# 다른 정수 값
print(hash(12346)) # 12346

# 소수 값
print(hash(15.1234))  # 284541027336970255
print(hash(15.1234))  # 284541027336970255

# 다른 소수 값
print(hash(81.1234))  # 284541027336978513

# 문자열
print(hash("파이썬"))  # -8002119629611903017
print(hash("파이썬"))  # -8002119629611903017

# 다른 문자열
print(hash("자바"))  # -8553573703343279427
```

여기서 중요한 점은, 서로 다른 두 값을 파라미터로 넣었을 때 같은 정수가 리턴될 수 없다는 것, 즉 데이터를 자신만의 고유한 정수 값으로 바꿔준다는 것이다. 지금까지 해시 함수의 key를 정수형으로만 생각했었는데, 다른 타입의 데이터들을 자신만의 고유한 정수 값으로 바꿀 수 있으면 이제 정수 뿐만 아니라 다른 자료형들도 key로 사용할 수 있다.

#### 한계

파이썬 `hash` 함수는 자체적으로는 불변 타입 자료형에만 사용할 수 있다.

- 불린형
- 정수형
- 소수형
- 튜플
- 문자열

해당 타입의 자료형만 `hash` 함수의 파라미터로 넘겨줄 수 있다.

### 해시 테이블 충돌과 Chaining 개념

만약 서로 다른 key가 해시 함수를 통해 같은 값을 가질 경우엔 어떻게 해야 할까? -> 이때 `충돌(collision)`이 일어났다고 한다.

Chaining: 배열 인덱스에 링크드 리스트를 저장해서 충돌을 해결하는 방법을 의미. 이를 통해 해시 테이블에서 충돌이 일어나도 key-value 쌍들을 모두 저장할 수 있다.

기존 링크드 리스트를 Chaining을 이용해서 바꿔볼 수 있다.

#### Node 클래스

여기선 크게 바꿀 건 없고, 링크드 리스트 노드가 변수 `data` 대신에 `key`와 `value`를 저장하도록 한다.

```Python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None # 다음 노드에 대한 레퍼런스
        self.prev = None # 전 노드에 대한 레퍼런스
```

#### LinkedList 클래스

링크드 리스트 클래스에서는 필요한 메소드들만 가지고 와서 쓰면 된다. 노드 클래스랑 마찬가지로 그대로 사용할 순 없고, 조금씩 고쳐서 써야 한다.

`__init__` 메소드는 그대로이다.

```Python
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None # 링크드 리스트의 가장 앞 노드
        self.tail = None # 링크드 리스트의 가장 뒤 노드
```

##### 탐색 메소드

```Python
def find_node_with_key(self, key):
    """링크드 리스트에서 주어진 데이터를 갖고 있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head # 링크드 리스트를 돌기 위해 필요한 노드 변수

    while iterator is not None:
        if iterator.key == key:
            return iterator
        iterator = iterator.next

    return None
```

탐색 메소드는 이제 특정 `data`를 갖는 노드를 찾는 게 아니라 특정 `key`를 갖는 노드를 찾는다. 이에 맞게 링크드 리스트를 처음부터 끝까지 돌면서 원하는 `key`를 갖는 노드를 리턴해주도록 수정해준다. 코드에서는 기존의 `data` 변수를 다 `key`로 바꿔주면 된다.

##### 추가(맨 뒤 삽입) 메소드

```Python
def append(self, key, value):
    """링크드 리스트 추가 연산 메소드"""
    new_node = Node(key, value)

    # 빈 링크드 리스트라면, head와 tail을 새로 만든 노드로 지정
    if self.head is None:
    self.head = new_node
    self.tail = new_node

    # 이미 노드가 있으면
    else:
        self.tail.next = new_node # tail의 다음 노드로 추가
        new_node.prev = self.tail
        self.tail = new_node # tail 업데이트
```

추가 메소드 `append`는 이제 파라미터로 `data` 대신 `key`와 `value`를 받는다. 링크드 리스트에 데이터를 더해줄 때는 항상 새로운 노드를 만들어줘야 하므로, 파라미터로 받은 정보를 `key`와 `value`로 갖는 새로운 노드를 만들어준다. 새 노드를 링크드 리스트에 연결해주는 부분 코드는 똑같다.

##### 삭제 메소드

```python
def delete(self, node_to_delete):
    """더블리 링크드 리스트 삭제 연산 메소드"""

    # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
    if node_to_delete is self.head and node_to_delete is self.tail:
        self.tail = None
        self.head = None

    # 링크드 리스트 가장 앞 데이터 삭제할 때
    elif node_to_delete is self.head:
        self.head = self.head.next
        self.head.prev = None

    # 링크드 리스트 가장 뒤 데이터 삭제할 때
    elif node_to_delete is self.tail:
        self.tail = self.tail.prev
        self.tail.next = None

    # 두 노드 사이에 있는 데이터 삭제할 때
    else:
        node_to_delete.prev.next = node_to_delete.next
        node_to_delete.next.prev = node_to_delete.prev
```

원래 링크드 리스트 삭제 메소드에선 노드를 삭제할 때 삭제하는 노드의 데이터를 리턴했지만 여기선 빼준다.

나머지 부분은 그대로이다. 더블리 링크드 리스트 삭제 메소드는 어차피 노드가 주어졌을 때 그 노드를 링크드 리스트에서 삭제해준다. 기존 `data` 변수나 `key.value` 변수와 전혀 관계가 없는 메소드이기 때문에 나머지 코드를 바꿀 필요가 없는 것이다.

##### 문자열 메소드

문자열 메소드는 출력 형식을 조금 바꿔줄 것이다.

```python
def __str__(self):
    """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
    res_str = ""

    # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
    iterator = self.head

    # 링크드 리스트 끝까지 돈다.
    while iterator is not None:
        # 각 노드의 데이터를 리턴하는 문자열에 더해준다.
        res_str += "{}: {}\n".format(iterator.key, iterator.value)
        iterator = iterator.next

    return res_str
```

원래는 링크드 리스트에 `2, 3, 5, 7, 11`이 들어있다면 `2 | 3 | 5 | 7 | 11` 이런 식으로 링크드 리스트의 모든 `data` 변수를 한 줄에 순서대로 출력했었는데, 이제는 `key`-`value` 쌍을 저장하므로 출력 형식도 바꿔줘야 한다.

링크드 리스트에 `101: "최지웅"`, `204: "강영훈"`, `305: "성태호"`이 들어 있다고 해보자. 그러면 아래와 같이 이 링크드 리스트를 출력했을 때 한 줄에 한 `key`, `value` 쌍 하나씩 나오도록 바꿔준 것이다.

```
101: 최지웅
204: 강영훈
305: 성태호
```

## 해시 테이블 연산

크게

- 탐색
- 삽입
- 삭제
  이 세 가지로 나눌 수 있다.

### 해시 테이블 탐색 연산

- 원하는 `key`에 해당하는 `value`를 찾는 연산

해시 테이블을 순환하면서 원하는 `data`를 갖고 있는 노드가 있는지 확인하는 것. 원하는 `data`를 찾으면, `value`를 리턴한다.

#### 탐색 연산 시간 복잡도

탐색의 경우, 가장 최악의 경우는 n개의 `key`-`value` 데이터 쌍이 모두 한 링크드 리스트에 저장된 경우이다.

<img width="816" alt="스크린샷 2021-02-12 오후 3 26 21" src="https://user-images.githubusercontent.com/61453718/107736974-acd96a00-6d46-11eb-8c29-a33cd411e6cb.png">

|                    | 탐색 연산 각 단계들 |
| ------------------ | ------------------- |
| 해시 함수 계산     | `O(1)`              |
| 배열 인덱스 접근   | `O(1)`              |
| 링크드 리스트 탐색 | `O(n)`              |
| 총합               | `O(n+2)` = `O(n)`   |

### 해시 테이블 삽입 연산

- `key`-`value` 데이터 쌍을 저장, 또는 수정

`key`를 해시 함수에 넣는다. 해시 함수의 결과값을 이용해서 배열의 인덱스에 접근한다. 그 후 저장된 링크드 리스트에 원하는 키를 갖는 노드가 있는지 탐색한다. 삽입하려는 `key`가 있는 지 먼저 확인해야 한다. 그렇지 않으면 같은 `key`를 가진 노드가 중복되기 때문이다. 하나의 `key`에는 하나의 `value`만 있을 수 있으므로 기존의 `value`를 바꿔준다.

#### 삽입 연산 시간 복잡도

|                                | 탐색 연산 각 단계들         |
| ------------------------------ | --------------------------- |
| 해시 함수 계산                 | `O(1)`                      |
| 배열 인덱스 접근               | `O(1)`                      |
| 링크드 리스트 노드 탐색        | `O(n)`                      |
| 링크드 리스트 저장 / 노드 수정 | `O(1)`                      |
| 총합                           | `O(1 + 1 + n + 1)` = `O(n)` |

삽입에서도 마찬가지로 탐색은 아래와 같다.
<img width="815" alt="스크린샷 2021-02-12 오후 3 36 17" src="https://user-images.githubusercontent.com/61453718/107737583-0e4e0880-6d48-11eb-8280-8827275deb8e.png">

### 해시 테이블 삭제 연산

- 원하는 `key`에 대한 `key`-`value` 데이터 쌍을 삭제

원하는 `key`에 있는 노드를 탐색한 후 원하는 `key`가 있으면 그 부분을 지워준다.

#### 삭제 연산 시간 복잡도

|                         | 탐색 연산 각 단계들         |
| ----------------------- | --------------------------- |
| 해시 함수 계산          | `O(1)`                      |
| 배열 인덱스 접근        | `O(1)`                      |
| 링크드 리스트 노드 탐색 | `O(n)`                      |
| 링크드 리스트 노드 삭제 | `O(1)`                      |
| 총합                    | `O(1 + 1 + n + 1)` = `O(n)` |

### Chaining을 쓰는 해시 테이블 평균 시간 복잡도

| 동작(Operation) | 시간 복잡도 |
| --------------- | ----------- |
| 탐색(search)    | `O(n)`      |
| 저장(save)      | `O(n)`      |
| 삭제(delete)    | `O(n)`      |

세 연산 모두 `key`를 이용해서 저장된 링크드 리스트 노드를 탐색하는 과정을 포함한다. 링크드 리스트 탐색 연산은 링크드 리스트의 길이에 비례한다.

해시 테이블이 사용하는 링크드 리스트의 길이가 가장 긴 경우는, 저장하는 모든 `key`-`value` 데이터 쌍이 하나의 링크드 리스트에 저장되는 경우이다. 해시 테이블에 저장된 `key`-`value` 쌍의 수가 n이라고 하면 최악의 경우 리스트의 길이도 n인 것이다. 길이가 n인 링크드 리스트를 탐색하는 데 걸리는 시간은 `O(n)`이다. 세 연산 모두 링크드 리스트를 탐색하는 단계를 포함한다. 그러므로 세 연산은 최악의 경우 `O(n)`이 걸린다.

최악의 경우만으로 연산의 효율성을 평가하는 게 불공평할 때 사용하는 방법 중 하나인 평균 시간 복잡도를 이용해서 해시 테이블 연산들을 분석해볼 수 있다.

### Open Addressing을 이용한 충돌 해결

- 충돌이 일어났을 때 다른 비어있는 인덱스를 찾아서 그곳에 데이터를 저장하는 방법

<img width="818" alt="스크린샷 2021-02-12 오후 7 16 12" src="https://user-images.githubusercontent.com/61453718/107755917-c7bbd680-6d66-11eb-9199-38addfd22593.png">

둘 다 인덱스 20이므로, 먼저 들어온 101이 20에 위치하고 이후 204는 다른 비어있는 21을 찾아 그곳에 저장된다.

비어있는 인덱스를 찾는 방법?

#### 선형 탐사(Linear Probing)

- 충돌이 일어났을 때, 한 칸씩 다음 인덱스가 비었는지 순서대로 선형적으로 확인

<img width="813" alt="스크린샷 2021-02-12 오후 7 20 31" src="https://user-images.githubusercontent.com/61453718/107756309-60eaed00-6d67-11eb-9b47-1b874a9bde0f.png">

20, 21이 차있는 상황에서, 새로운 데이터가 들어올 때 20부터 한 칸씩 다음 인덱스가 비었는지 확인한 후, 22가 비어있는 것을 확인하고 22에 데이터를 삽입하는 방식.

#### 제곱 탐사(Quadratic Probing)

<img width="773" alt="스크린샷 2021-02-12 오후 7 22 39" src="https://user-images.githubusercontent.com/61453718/107756528-adcec380-6d67-11eb-8648-f3941f81c2fd.png">

특정 값을 저장하고자 하는데 함수 결과가 10이 나왔다고 하자. 인덱스 10에는 이미 데이터가 저장돼 있다.

선형 탐사와 다르게 제곱 탐사는 처음에 1의 제곱 뒤에 있는 인덱스를 확인한다.

1의 제곱은 1이므로 인덱스 11 확인 -> 11은 차있음. 그 다음 2의 제곱인 4칸을 이동하여 15 확인 -> 15도 차있음. 그 다음 3의 제곱인 9칸을 이동하여 24 확인 -> 24는 비어있음. 여기에 새로운 `key`-`value` 쌍 데이터를 저장함.

제곱 탐사는 이러한 방식으로 선형적으로 바로 다음 인덱스들을 하나씩 확인하지 않고, 제곱을 한 값들을 이용해서 인덱스를 찾는다.

### Open Addressing 탐색 / 삭제 연산

#### 탐색 연산

<img width="816" alt="스크린샷 2021-02-12 오후 7 28 24" src="https://user-images.githubusercontent.com/61453718/107757137-7c0a2c80-6d68-11eb-969f-2234e6fdc925.png">

해시 함수 값의 결과에 따른 인덱스를 확인한다. 해시 함수의 값과 동일한지 파악한 후 다르면 선형적으로 다음 인덱스로 이동한다. 22에 찾고 있는 키가 있으므로, 해당 `value`를 리턴한다.

<img width="816" alt="스크린샷 2021-02-12 오후 7 30 47" src="https://user-images.githubusercontent.com/61453718/107757374-cf7c7a80-6d68-11eb-86cb-62f08eaeb4fe.png">

헌데, 비어있는 인덱스를 찾은 경우는 어떤 경우일까? -> 탐색하는 키에 대한 데이터가 처음부터 저장되지 않았다는 뜻이다. 처음에 탐색을 사다가 비어있는 곳이 있으면 그 부분에 데이터를 저장하는 방식이기 때문에, 비어있는 인덱스가 있을 수가 없다.

#### 삭제 연산

탐색을 할 때 빈 인덱스를 찾으면, 처음부터 데이터가 저장되지 않았다는 뜻이라고 했다. 마지막 인덱스에 데이터 쌍을 저장했는데, 그 앞 인덱스를 지워버리면 실제로 있는 인덱스를 <b>비어있는 인덱스가 있다는 이유로</b> 그 뒷부분까지 가지 않고 탐색을 종료해버린다. 이런 문제를 해결하기 위해

<img width="815" alt="스크린샷 2021-02-12 오후 7 34 09" src="https://user-images.githubusercontent.com/61453718/107757732-487bd200-6d69-11eb-9a77-9af7968784db.png">

이와 같이 `DELETED` 혹은 따로 약속된 표시를 해준다. 원래는 이 인덱스에 데이터가 있었으나 지금은 삭제됐다는 것을 보여주는 것이다. 이렇게 하면 저장되어있는 모든 인덱스를 찾을 수 있다.

출처: [코드잇](https://codeit.kr)
