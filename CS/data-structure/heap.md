# 자료구조

## 힙 (heap)

두 가지 조건을 만족하는 자료 구조이다.

1. 형태 속성: 힙은 완전 이진 트리여야 한다.

<img width="814" alt="스크린샷 2021-02-18 오후 9 29 18" src="https://user-images.githubusercontent.com/61453718/108357151-65fce000-7230-11eb-9ead-d4bd47bb7aa1.png">

2. 힙 속성: 힙 내에 있는 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같아야 한다.

<img width="815" alt="스크린샷 2021-02-18 오후 9 30 42" src="https://user-images.githubusercontent.com/61453718/108357279-8fb60700-7230-11eb-8ef4-4415b4239d32.png">

힙을 통해 정렬 문제를 해결할 수 있고(`11, 2, 5, 7, 3` -> `2, 3, 5, 7, 11`),

또한 우선순위 큐를 구현할 수 있다.

### 정렬

여러 개의 데이터 요소들을 특정 순서로 배치하는 것

ex) `[4, 1, 6, 2, 8, 5]`인 파이썬 리스트

1. 오름차순 배치 -> `[1, 2, 4, 5, 6, 8]`
2. 내림차순 배치 -> `[8, 6, 5, 4, 2, 1]`

- 정렬 알고리즘: 데이터를 재배치하는 구체적인 방법

  - 삽입 정렬
  - 선택 정렬
  - 퀵 정렬
  - 합병 정렬

### 배열로 구현한 힙

- 완전 이진 트리이므로 동적 배열로 구현한다.

<img width="815" alt="스크린샷 2021-02-20 오후 8 50 45" src="https://user-images.githubusercontent.com/61453718/108594430-54950e80-73bd-11eb-9bdc-035617fb60a1.png">

해당 힙은 파이썬 리스트로 이렇게 구현이 된 것이다. 한 인덱스가 한 노드를 나타낸다.

`왼쪽 자식 인덱스: 인덱스 * 2`, `오른쪽 자식 인덱스: 인덱스 * 2 + 1`

### 힙 만들기

<img width="818" alt="스크린샷 2021-02-20 오후 8 53 50" src="https://user-images.githubusercontent.com/61453718/108594505-bd7c8680-73bd-11eb-931c-9d20cc3eb5c7.png">

이 트리는 힙일까? 힙이 되기 위해서는 두 가지 조건을 만족해야 한다.

1. 형태 속성: 이 트리가 완전 이진 트리인가?의 여부

   - 마지막 레벨 빼고 다 채워져 있고, 마지막 레벨도 왼쪽부터 오른쪽 방향으로 채워져 있으므로 완전 이진 트리가 맞다. -> 형태 속성 충족

2. 힙 속성: 부모 노드가 자식 노드보다 큰 값을 가져야 한다.
   - 노드 2의 데이터는 자식들의 데이터보다 작으므로 충족하지 못함.

따라서 힙이 아니다.

부모 노드보다 자식 노드가 더 클 경우 그 두 노드를 바꿔주면 된다. (`heapify`)

부모 노드, 왼쪽 자식, 오른쪽 자식 중 가장 큰 노드를 고른다. 가장 큰 노드가 부모 노드가 아니라면 부모 노드와 해당 노드를 바꿔준다. 이런 방식으로 `heapify`를 해줘서 힙의 조건을 충족할 때까지 반복한다.

#### 시간 복잡도

<img width="816" alt="스크린샷 2021-02-21 오후 1 34 09" src="https://user-images.githubusercontent.com/61453718/108615635-7fc53f80-7449-11eb-88f2-f203db629031.png">

이미지에서처럼 최악의 경우는, `root` 노드가 계속 내려가서 `leaf` 노드까지 내려가는 경우이다.

힙은 완전 이진 트리이기 때문에 높이가 `O(log(n))`이다. 최악의 경우 `heapify`에 걸리는 시간은 `O(log(n))`에 비례하므로 시간 복잡도 또한 `O(log(n))`이다.

### 힙 만들기 II

heapify: 파라미터로 넘기는 노드가 힙에서 위치를 찾아간다. 노드 10부터 1까지 순서대로 넣어서 호출하면 어떻게 될까?

<img width="811" alt="스크린샷 2021-02-22 오후 3 47 22" src="https://user-images.githubusercontent.com/61453718/108672337-43ffa800-7525-11eb-810a-c7cbf69fc2b3.png">

노드 6~10까지는 `leaf node`이므로 `heapify`를 통해 바뀌는 게 없다. 5부터는 가정을 해야 한다.

<img width="804" alt="스크린샷 2021-02-22 오후 3 49 30" src="https://user-images.githubusercontent.com/61453718/108672527-8f19bb00-7525-11eb-92f3-421c4f4b07b6.png">

노드 2의 이전 노드까지는 `heapify`가 되어 있기 때문에 이미 힙 속성을 지키고 있다고 할 수 있다. 이 부분에서 노드 2에 `heapify`를 해준다면..

<img width="804" alt="스크린샷 2021-02-22 오후 3 51 09" src="https://user-images.githubusercontent.com/61453718/108672637-ca1bee80-7525-11eb-94b7-5812a7bfe74a.png">

다음과 같이 노드 2와 그 아래 모든 노드들이 힙 속성을 가지게 된다.

<img width="804" alt="스크린샷 2021-02-22 오후 3 51 59" src="https://user-images.githubusercontent.com/61453718/108672726-e750bd00-7525-11eb-92cc-2ad48241c117.png">

1을 제외한 모든 노드들에 대해 `heapify`를 해줬기 때문에, 다음과 같이 모든 노드가 이미 힙 속성을 지키고 있게 된다. 이제 `root`에 `heapify`를 해 주면,

<img width="814" alt="스크린샷 2021-02-22 오후 3 53 00" src="https://user-images.githubusercontent.com/61453718/108672833-0bac9980-7526-11eb-9841-f99610cd2918.png">

모든 노드가 힙 속성을 갖고 있으므로, `힙을 만들었다` 라고 할 수 있게 되는 것이다.

<img width="814" alt="스크린샷 2021-02-22 오후 3 53 00" src="https://user-images.githubusercontent.com/61453718/108672833-0bac9980-7526-11eb-9841-f99610cd2918.png">

정리하자면, 마지막 노드부터 반대 순서로 `heapify`를 해주면 힙으로 만들 수 있는 것이다.

#### 시간 복잡도

힙을 만드는 데 걸리는 시간은?

<img width="814" alt="스크린샷 2021-02-22 오후 3 55 41" src="https://user-images.githubusercontent.com/61453718/108673098-6ba34000-7526-11eb-9034-0f2fcc292898.png">

한 번 `heapify`할 때 걸리는 시간은 `O(log(n))`인데, 모든 `n`개의 노드에 대해 `heapify`를 하므로, 총 걸리는 시간은 `O(nlog(n))`이 된다.

### 힙 정렬

> 힙을 이용한 정렬 알고리즘

<img width="815" alt="스크린샷 2021-02-22 오후 3 57 37" src="https://user-images.githubusercontent.com/61453718/108673236-b0c77200-7526-11eb-93ba-4fafeb4eecca.png">

`root` 노드와 노드 10을 바꿔줬다고 해보자. 그럼 위와 같은 형태로 바뀐다. 힙 속성이 망가진 것이다. 힙 속성을 맞추기 위해 `root` 노드에 `heapify`를 호출한다.

이 때, **노드 10은 없는 노드 취급을 해줘야 한다.** 데이터가 저장되어 있긴 하지만 없는 것처럼 무시해야 한다.

<img width="814" alt="스크린샷 2021-02-22 오후 3 59 07" src="https://user-images.githubusercontent.com/61453718/108673378-e704f180-7526-11eb-801c-91d4ee210a70.png">

`heapify`를 해 주면, **노드 10을 제외하고** 힙 속성을 충족하는 힙이 완성된다. `root` 노드에 12가 저장돼 있다.

<img width="814" alt="스크린샷 2021-02-22 오후 4 01 05" src="https://user-images.githubusercontent.com/61453718/108673539-2cc1ba00-7527-11eb-94cd-b24731ca58b7.png">

이번에도 `root` 노드를 노드 9와 바꿔준다. 이렇게 한 후 마찬가지로 `heapify`를 해 주면, **노드 10과 9를 제외하고** 힙 속성을 충족하는 힙이 완성된다.

이런 방식으로 계속 마지막 노드와 바꿔준 후 의도적으로 망가뜨린 힙 속성을 다시 충족해주기 위해 `heapify`를 반복하게 되면..

<img width="812" alt="스크린샷 2021-02-22 오후 4 03 07" src="https://user-images.githubusercontent.com/61453718/108673698-75797300-7527-11eb-9501-49df271799eb.png">

결국 이렇게 값 순서대로 저장된 트리가 완성된다. 데이터가 오름차순으로 정렬된다. 이러한 방식이 바로 **힙 정렬**이다.

이를 일반화해서 표현해보면:

`힙을 만든다` -> `root 노드와 마지막 노드를 바꿔준다.` -> `(바꾼 노드는 없는 노드로 취급한다)` -> `새로운 노드가 힙 속성을 지킬 수 있게 heapify를 호출한다`

여기서 2~4번째 순서를 반복해주는 것이다.

**만약 내림차순으로 정렬하고 싶을 경우?**

    - 힙 속성을 반대로 바꾸고(자식 노드의 데이터가 부모 노드의 데이터보다 커야 한다) 똑같은 알고리즘을 적용하면 된다.

### 힙 정렬 구현해보기

어떤 리스트(`[None, 6, 1, 4, 7, 10, 3, 8, 5, 1, 5, 7, 4, 2, 1]`)가 있다고 해 보자. 이 리스트를 힙 정렬하려면

1. 먼저 리스트를 힙으로 만든다
2. `root` 노드와 마지막 노드의 위치를 바꾼다. 마지막 위치로 간 기존의 `root` 노드는 이제 힙에서 없다고 가정한다.
3. 새로운 `root` 노드가 힙 속성을 지킬 수 있게 `heapify` 한다.
4. 힙에 남아 있는 노드가 없도록 2. 와 3. 을 반복한다.

### 힙 정렬 시간 복잡도

힙 안에 있는 노드의 개수를 `n`이라고 했을 때 정렬의 시간 복잡도는 어떻게 될까?

1. 먼저 리스트를 힙으로 만든다: 이 경우 걸리는 시간은 앞에서 썼듯이 `O(n*log(n))`이다. 이는 한 번의 `heapify`를 할 때의 시간 복잡도가 `O(log(n))`이고, 노드의 수가 총 `n`개이기 때문이다.

2. `root`노드와 마지막 노드의 위치를 바꾼다: 그냥 두 노드의 위치만 바꿔주는 작업이기 때문에 노드의 개수 `n`과는 상관없이 항상 `O(1)`이다.

3. 새로운 `root` 노드가 힙 속성을 지킬 수 있게 `heapify`한다: 이 때의 시간 복잡도는 `O(log(n))`이라고 했다. 2. 와 3. 을 합치면 `O(log(n) + 1)`, 즉 `O(log(n))`이다.

4. 힙에 남아 있는 노드가 없도록 2. 와 3. 을 반복한다: 힙에는 총 `n`개의 노드가 있으므로 2, 3, 4단계의 시간 복잡도를 종합하면 `O(n*log(n))`이라고 할 수 있다.

정리하면

- 힙을 만드는 데 `O(n*log(n))`
- 만든 힙에서 매번 `root` 노드를 뽑고 남은 것들을 다시 힙으로 만들어주는 작업을 반복하는 데 `O(n*log(n))`이 걸린다.

두 시간 복잡도를 합치면 `O(2*n*log(n))`이고, 시간 복잡도에서 상수는 무시되므로 결국 `O(n*log(n))`이라고 할 수 있다.

따라서 종합적으로 힙 정렬은 `O(n*log(n))`의 시간 복잡도를 가지는 정렬 알고리즘인 것이다.

#### 다른 정렬 알고리즘들과의 비교

아래 표에는 힙 정렬과 가장 대표적인 정렬 알고리즘 4개의 시간 복잡도가 있다.

| 정렬 알고리즘 | 시간 복잡도                       |
| ------------- | --------------------------------- |
| 선택 정렬     | `O(n^2)`                          |
| 삽입 정렬     | `O(n^2)`                          |
| 합병 정렬     | `O(n*log(n))`                     |
| 퀵 정렬       | 평균 `O(n*log(n))`(최악 `O(n^2)`) |
| 합 정렬       | `O(n*log(n))`                     |

힙 정렬은 선택 정렬과 삽입 정렬(`O(n^2)`)보다는 좋고, 합병 졍렬과 퀵 정렬(`O(n*log(n))`)과는 비슷한 성능을 내는 정렬 방법이라는 것을 알 수 있다.

## 우선순위 큐

힙은 크게 두 가지 목적으로 사용되는데, 첫 번째는 정렬이고 두 번째가 `우선순위 큐`이다.

우선순위 큐는 추상 자료형에 속함(내부적인 구현보다 기능에 집중하게 해주는 개념))

- 데이터를 저장할 수 있다.
- 저장한 데이터가 우선순위 순서대로 나온다.

```py
# 최대 우선순위 큐
priority_queue = MaxPriorityQueue()

# 우선순위 큐에 데이터 삽입
priority_queue.add(5)
priority_queue.add(2)
priority_queue.add(7)
priority_queue.add(8)

# 우선순위 큐 데이터 추출(삭제)
print(priority_queue.pop())
print(priority_queue.pop())
print(priority_queue.pop())
print(priority_queue.pop())
```

결과

```
8
7
5
2
```

가장 우선순위가 높은 데이터부터 처리하고 싶을 때 유용하게 쓸 수 있는 추상 자료형이다.
ex) 고객 문의 처리 시 **가장 불만도가 높은 고객의 문의부터 처리하고 싶을 때**, **가장 등급이 높은 고객의 문의부터 처리하고 싶을 때**

힙을 이용해서 우선순위 큐를 쉽게 만들 수 있다.

### 힙에 데이터 삽입하기

<img width="818" alt="스크린샷 2021-02-26 오후 4 34 51" src="https://user-images.githubusercontent.com/61453718/109269905-8dffcb00-7850-11eb-9dc4-ea705ed8062e.png">

이 힙에 데이터 `15`를 삽입한다고 해 보자. 그럼 일단 마지막 노드에 15가 들어가게 되는데, 이 경우 힙 속성을 어기게 된다. 15가 힙 속성을 지키도록 위치를 바꿔줘야 한다.
부모 노드 8보다 크므로 두 개를 바꿔주고, 바꾼 뒤에 위치한 노드를 기준으로 한 부모 노드 14보다 15가 더 크기 때문에 두 개를 다시 바꿔준다. `root` 노드보단 작으므로 이 때 힙 속성을 지키게 된다.

<img width="813" alt="스크린샷 2021-02-26 오후 4 38 00" src="https://user-images.githubusercontent.com/61453718/109270172-fea6e780-7850-11eb-90d2-3110fa7dc783.png">

이 알고리즘을 일반화해보면:

- 힙의 마지막 인덱스에 데이터를 삽입한다.
- 삽입한 데이터와 부모 노드의 데이터를 비교한다.
- 부모 노드의 데이터가 더 작으면 둘의 위치를 바꿔준다.
- 새로 삽입한 노드가 제 위치를 찾을 때 까지 위의 두 과정을 반복한다.
