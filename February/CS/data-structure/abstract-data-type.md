# 자료구조

## 추상 자료형 (Abstract Data Type)

### 기능 vs 구현

삽입 연산(insert operation)의 기능과 구현?

기능: 연산이 "무엇을" 하는지에 관한 내용.

- 삽입 연산의 기능: "순서 데이터에서 원하는 위치에 데이터를 저장"

구현: 기능을 "어떻게" 하는지에 관한 내용

- 링크드 리스트와 동적 배열 등에서 삽입을 하는 방법은 각각 달랐다.

### 추상화

```python
def insert(data_type, index, element):
    """자료형 data_type의 위치 index에 데이터 element를 삽입해주는 함수""" # 함수의 기능만 알아도 사용할 수 있음 -> 추상화를 했음
```

#### 추상 자료형

- 자료 구조를 추상화한 것

- 데이터를 저장 / 사용할 때 기능만 생각

### 추상 자료형 vs 자료 구조

1. 리스트 (추상 자료형)

- 데이터간 순서 관계를 유지할 수 있다.
  - 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
  - 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다.
  - 삽입 연산: 특정 위치에 새로운 데이터를 저장한다.
  - 삭제 연산: 특정 위치에 있는 데이터를 지운다.
- 연산의 "기능들"만 갖고 있음. 구현 과정은 포함되어있지 않음.

2. 동적 배열 (자료 구조)

- 데이터를 메모리에 순서대로, 그리고 연속적으로 저장한다.
  - 접근 연산: 인덱스 주소를 한 번에 계산해서 메모리에 접근한다.
  - 탐색 연산: 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다.
  - 삽입 연산: 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다.
  - 삭제 연산: 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다.
- 데이터를 어떻게 저장할 건지, 데이터를 어떻게 유지할 건지, 각 연산을 구체적으로 어떻게 할 지를 묶어둔 개념이다.

확실히 차이가 보인다.

<img width="812" alt="스크린샷 2021-02-13 오후 1 30 33" src="https://user-images.githubusercontent.com/61453718/107841610-a8bd5300-6dff-11eb-8622-c0c71701c903.png">

리스트라는 추상 자료형을 동적 배열이라는 자료 구조로 구현할 수도 있고, 링크드 리스트라는 자료구조로 구현할 수도 있다.

프로그래밍을 할 때 자료 구조보다 추상 자료형을 떠올리는 게 더 편하다.

- 데이터를 메모리에 순서대로 저장하고 바꾸고 싶다. (기능)

  - 구현에 대해 생각할 필요 없는 추상 자료형을 생각해서 -> 리스트를 사용해서 이 위치에 데이터를 저장해야겠다고 생각하면 편하다.
  - 자료 구조를 생각한다면,

  ```
  동적 배열을 쓰면 메모리에 데이터를 연속적이고 순차적으로 저장해서...
  새로운 위치에 데이터를 저장하려면 모든 데이터를 뒤로 밀고 새로 생겨난 자리에...
  아니면 링크드 리스트를 써서...
  ```

  이렇게 하나하나 과정을 생각하다보면 상당히 복잡해질 수 있다.

- 결국, 추상 자료형을 생각한다면 코드의 흐름에 집중할 수 있게 되는 것이다.

### 리스트(list)

- 데이터간 순서 관계를 유지할 수 있다.

  - 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
  - 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다.
  - 삽입 연산: 특정 위치에 새로운 데이터를 저장한다.
  - 삭제 연산: 특정 위치에 있는 데이터를 지운다.

- 파이썬
  - 추상화가 많이 된 고수준 언어
  - 많은 자료형 이름이 추상 자료형이다.
    - 파이썬 자료형 list -> 구현을 몰라도 기능만 알고 사용할 수 있음

```python
# 파이썬 리스트 생성
trending = []

# 특정 위치에 데이터 삽입
trending.insert(0, "연예인 A씨")
trending.insert(1, "잠실 콘서트")
trending.insert(2, "한국 휴일 수")
trending.insert(3, "추석 음식")

print(trending) # 리스트 출력

# 괄호를 이용한 인덱스 접근
print(trending[0])
print(trending[1])

trending[2] = 4

print(trending)

# in을 이용한 탐색
print("연예인 A씨" in trending)
print("연예인 B씨" in trending)

# del을 이용한 삭제
del trending[0]

print(trending)
```

결과

```
['연예인 A씨', '잠실 콘서트', '한국 휴일 수', '추석 음식']
연예인 A씨
잠실 콘서트
['연예인 A씨', '잠실 콘서트', 4, '추석 음식']
True
False
['잠실 콘서트', 4, '추석 음식']
```

#### 리스트 구현

|             | 동적 배열        | 더블리 링크드 리스트 |
| ----------- | ---------------- | -------------------- |
| 접근        | `O(1)`           | `O(n)`               |
| 탐색        | `O(n)`           | `O(n)`               |
| 접근 + 삽입 | `O(n)`           | `O(n)`               |
| 접근 + 삭제 | `O(n)`           | `O(n)`               |
|             |                  |                      |
| 맨 앞 삽입  | `O(n)`           | `O(1)`               |
| 맨 앞 삭제  | `O(n)`           | `O(1)`               |
| 맨 뒤 삽입  | 분할 상환 `O(1)` | `O(1)`               |
| 맨 뒤 삭제  | 분할 상환 `O(1)` | `O(1)`               |

동적 배열은 데이터를 수정하거나 가져오는 접근 연산, 그리고 맨 끝에 데이터를 삽입, 삭제하는 연산을 효율적으로 할 수 있고, 링크드 리스트는 처음과 끝에 데이터를 삽입, 삭제하는 연산을 효율적으로 할 수 있다. 리스트에서는 어떤 걸 써야될까?

- 각 리스트에서 많이 사용할 연산에 대한 시간 복잡도를 비교해보면 된다.

1. 접근: 동적 배열의 접근 연산이 더 효율적 -> 동적 배열을 사용
2. 가장 앞에 데이터 삽입: 링크드 리스트가 더 효율적 -> 링크드 리스트를 사용

### 큐(Queue)

- FIFO(First In First Out)의 형태를 취한다. 앞에서만 삭제하고 뒤에서만 삽입한다.

  - 가장 먼저 들어온 데이터가 가장 먼저 삭제된다.

- 데이터간 순서 관계를 유지할 수 있다.

  - 맨 뒤 데이터 추가
  - 맨 앞 데이터 삭제
  - 맨 앞 데이터 접근

- 파이썬에서 `deque`(Doubly-ended-que: 양면 큐)를 import해와서 쓸 수 있다.
  - 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형이다.

```python
# deque는 Python의 collections 모듈에서 갖고온다.
from collections import deque

queue = deque()

# 큐의 맨 끝에 데이터 삽입
queue.append("태호")
queue.append("현승")
queue.append("지웅")
queue.append("동욱")
queue.append("신의")

print(queue) # 큐 출력

# 큐의 가장 앞 데이터에 접근
print(queue[0])

# 큐의 맨 앞 데이터 삭제
print(queue.popleft()) # popleft는 삭제한 데이터를 리턴하기도 한다.
print(queue.popleft())
print(queue.popleft())

print(queue)
```

결과

```
deque(['태호', '현승', '지웅', '동욱', '신의'])
태호
태호
현승
지웅
deque(['동욱', '신의'])
```

#### 큐 구현

리스트와 마찬가지로 큐 또한 동적 배열, 링크드 리스트로 구현할 수 있다.

|            | 동적 배열        | 더블리 링크드 리스트 |
| ---------- | ---------------- | -------------------- |
| 맨 앞 삭제 | `O(n)`           | `O(1)`               |
| 맨 뒤 삽입 | 분할 상환 `O(1)` | `O(1)`               |
| 맨 앞 접근 | `O(1)`           | `O(1)`               |

삭제의 경우 동적 배열보다 링크드 리스트의 시간 복잡도가 덜하므로 큐의 경우는 링크드 리스트를 쓰는 것이 더 효율적이다. Python의 `deque` 또한 더블리 링크드 리스트로 구현되어 있다.

### 스택(Stack)

스택은 항상 맨 끝에 추가하고, 삭제할 때도 맨 끝에 삭제한다.
LIFO: Last-In-First-Out (가장 마지막에 들어온 데이터가 가장 먼저 삭제된다.)

- 데이터간 순서 관계를 유지할 수 있다.
  - 맨 뒤 데이터 추가
  - 맨 뒤 데이터 삭제
  - 맨 뒤 데이터 접근

Python에서 스택의 이름을 갖는 자료형은 없으나, 대신 큐를 사용할 때와 똑같이 `deque`를 이용해서 스택 연산을 할 수 있다.

    - 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형이다.
