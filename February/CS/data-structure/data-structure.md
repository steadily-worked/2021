# 자료구조

- 자료 구조의 목적: 자료를 구조화하여 데이터를 효율적으로 사용하는 것.
- 컴퓨터에 데이터가 어떻게 저장되는지를 알아야 함.

### 자료가 저장되는 곳

#### 스토리지(Storage)

- 데이터가 영구적으로 저장되는 곳. 사용자가 직접 지우거나 하지 않는 이상 사라지지 않는다.
- 데이터를 저장하고 받아오는 게 느리다.

#### 메모리(RAM)

- 데이터가 임시로 저장되는 곳. 임시적으로 저장된 것이기 때문에 컴퓨터가 꺼지면 날아감.
- 여기서 '저장'을 누를 경우 스토리지에 저장되고 영구적으로 남음
- 데이터를 저장하고 받아오는 게 빠르다.
- 지금 당장 사용해야 되는 데이터를 저장한다.

> 자료구조는 스토리지가 아닌, '메모리'를 위주로 구성됨

### RAM: Random Access Memory(임의 접근 메모리)

- 일정한 칸으로 나눠져 있다.
- 각 칸에 데이터를 저장할 수 있다.
- 각 칸은 자신만의 주소가 있다.
- 임의 접근: 저장 위치를 알면 접근할 때 항상 일정한 시간이 걸림
- 자료 구조에서, `메모리에 데이터를 저장`하고 `메모리에 저장된 데이터를 찾는` 얘기가 계속해서 나오게 될텐데, 메모리는 임의접근 하고 있다는 것을 항상 기억해야 함.

### 레퍼런스

- X = 95 -> "X는 95다 (X)", "X는 95를 가리킨다 (O)"
  레퍼런스는, 데이터에 접근할 수 있게 해주는 값을 포괄적으로 말한다. "주소"보다 조금 더 포괄적인 표현이다. 자료 구조를 배울 때는 "주소 = 레퍼런스" 라고 생각해도 된다.
- x = 95라는 변수를 사용할 때는, 저장된 값을 알아서 받아오기 때문에

```python
x = 95
print(x + 5) => print(95 + 5)
```

이렇게 생각해도 큰 무리는 없다.

<h2>배열</h2>

C 배열과 다르게 파이썬 배열에서는 값을 가리키는 용도 정도로만 배열을 사용하기 때문에, 아무리 큰 데이터가 있다 한들 크게 상관이 없다.

정적 배열: 크기 고정 (요소 수 제한, 이후에 바꿀 수 없음)
동적 배열: 크기 변함 (요소 계속 추가 가능). 정적 배열로 만들어진 자료 구조이며 정적 배열의 크기를 상황에 맞게 조절한다.

<h3>분할 상환 분석</h3>

분할 상환 분석은 연산을 n번 했을 때 총 드는 시간 X를 n으로 나눠주는 "할부" 개념이다. 최악의 경우로 시간 복잡도를 얘기하는 것이 비합리적인 경우에 사용한다. 동적 배열의 추가(append) 연산에 직접 분할 상환 분석을 해보자.

<h4>동적 배열 동작</h4>

동적 배열에 추가를 할 때는:

1. 새로운 인덱스에 데이터를 저장하는 시간
2. 기존 배열의 크기가 부족해서 더 큰 배열을 만들고, 기존 배열의 데이터들을 옮기는 시간

이 두 가지를 나눠서 생각하면 편하다.

우선 동적 배열에 데이터를 추가할 때 일어나는 일을 나열해 볼 것이다.

비어있는 동적 배열에 추가 연산 9번을 한다고 가정하자. 처음 시작할 때 동적 배열은 크기가 1인 배열이다.

1. 첫 번째 요소 추가:
   1. 그냥 새로운 데이터를 저장한다.
2. 두 번째 요소 추가:
   1. 배열이 꽉 차서, 크기가 2인 배열을 새로 만들고 기존 데이터를 옮겨 저장한다(1개 옮겨 저장)
   2. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
3. 세 번째 요소 추가:
   1. 배열이 꽉 차서, 크기가 4인 배열을 새로 만들고 기존 데이터를 옮겨 저장한다(2개 옮겨 저장)
   2. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
4. 네 번째 요소 추가:
   1. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
5. 다섯 번째 요소 추가
   1. 배열이 꽉 차서, 크기가 8인 배열을 새로 만들고 기존 데이터를 옮겨 저장한다(4개 옮겨 저장)
   2. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
6. 여섯 번째 요소 추가:
   1. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
7. 일곱 번째 요소 추가:
   1. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
8. 여덟 번째 요소 추가:
   1. 맨 뒤 인덱스에 새로운 데이터를 저장한다.
9. 아홉 번째 요소 추가:
   1. 배열이 꽉 차서, 크기가 16인 배열을 새로 만들고 기존 데이터를 옮겨 저장한다(8개 옮겨 저장)
   2. 맨 뒤 인덱스에 새로운 데이터를 저장한다.

이런 식으로 내부 배열이 꽉 찼을 때는 새로운 배열을 만들고, 기존 요소들을 복사하고, 새로운 요소를 저장하면 된다. 그리고 배열에 여유가 있으면 그냥 새로운 요소만 저장하면 된다.

<h3>분할 상환 분석</h3>

분할 상환 분석을 하면 이 동작을 n번 반복한다고 가정한다. 총 걸리는 시간을 계산하기 쉽게 두 가지로 나눠서 생각해 볼 것이라고 했다.

1. 새로운 데이터를 동적 배열 맨 끝에 단순히 저장하는 데 걸리는 시간
2. 더 큰 배열을 만들고 그 배열에 기존의 데이터를 옮기는 데 걸리는 시간

걸리는 두 시간을 각각 따로 계산해 보자.

<h4>배열 끝에 새로운 데이터를 저장하는 데 걸리는 시간</h4>

먼저 새로운 데이터를 저장하는 데 걸리는 총 시간에 대해서 생각해보자.

| x번째 추가 | 배열 끝에 데이터 저장하는 데 걸리는 시간 |
| ---------- | ---------------------------------------- |
| 1          | 1                                        |
| 2          | 1                                        |
| 3          | 1                                        |
| 4          | 1                                        |
| 5          | 1                                        |
| 6          | 1                                        |
| 7          | 1                                        |
| 8          | 1                                        |
| 9          | 1                                        |
| ...        | 1                                        |
| n          | 1                                        |

인덱스에 데이터를 저장하는 데 걸리는 시간은 1이라고 했었다. 이걸 총 n번 하는 것이므로 O(n)이 걸린다.

<h4>새로운 배열에 데이터를 옮기는 시간</h4>

이번에는 내부 배열이 꽉 차서 기존 데이터를 복사하는 데 걸리는 시간에 대해서 생각해 보자.

| x번째 추가 | 배열 크기 | 새로운 배열에 요소 옮겨 저장하는 데 걸린 시간 |
| ---------- | --------- | --------------------------------------------- |
| 1          | 1         | 0                                             |
| 2          | 2         | 1                                             |
| 3          | 4         | 2                                             |
| 4          | 4         | 0                                             |
| 5          | 8         | 4                                             |
| 6          | 8         | 0                                             |
| 7          | 8         | 0                                             |
| 8          | 8         | 0                                             |
| 9          | 16        | 8                                             |
| ...        |           |                                               |
| n          |           |                                               |

새로운 배열에 기존 데이터를 옮겨 저장하는 시간은 위 표에 나와있는 대로 소요된다.

표를 살펴보자. 2, 3, 5, 9번째 추가 때 배열의 크기를 늘려야 한다. 그럴 때마다 데이터를 옮겨야 하는데, 이 때 데이터를 각각 1, 2, 4, 8개씩 복사하고 붙여 넣는다.

데이터를 복사해서 붙여 넣는 총 시간 비용은 이 시간들을 더한 8+4+2+1이다. 좀 더 일반화해서 생각해보자.

추가 연산을 n번 했을 때, 가장 마지막에 데이터를 m개 옮겨서 저장했다고 해보자.

그럼 데이터를 복사해서 저장하는 데 걸린 총 시간은: m + m/2 + m/4 + ... + 1 이렇게 표현할 수 있다.

이런 식으로 어느 자연수든 반씩 줄여서 1까지 계속 더해주면, 그 결과는 절대 2m을 넘을 수 없다. 정확히 말하면 딱 2m-1이 된다.

근데, 가장 최근에 데이터를 옮겨 저장할 때 8이 걸렸다는 것은 무슨 의미일까? 원래 배열의 수용 가능 크기가 8이었지만 크기가 부족해서 16개의 데이터를 담을 수 있는 새로운 배열로 복사했다는 뜻이다. 그럼 결국에 현재 배열 안에 있는 데이터는 9개~16개 사이라는 뜻이다. 16개보다 더 많은 요소가 있으면 가장 최근에 옮겨 저장한 요소가 8이 아니라 16일 것이다.

이 사실을 바탕으로, 우리가 일반화할 때 사용했던 배열 안 요소 수 n과 가장 최근 옮겨 저장한 요소 수 m의 관계에 대해 한 가지 사실을 알아낼 수 있었다.

가장 최근에 복사하는 데 걸린 시간이 8일 때, 배열 안에 있는 데이터는 9개~16개 사이이다. 즉 m은 무조건 n보다 작다고 할 수 있다.

추가 연산을 연속으로 n번 하고, 가장 마지막에 옮겨 저장한 데이터 요소 수를 m이라고 할 때:

- 복사해서 저장하는 데 걸리는 총 시간이 2m - 1 이고
- m은 n보다 작다

이걸 다시 정리해서 나타내면,

<b>연속으로 추가 연산 n번을 하면 데이터를 옮겨서 저장하는 데 걸리는 총 시간은 2n보다 작다</b>

라고 할 수 있다.

<h4>두 경우 합치기</h4>

지금까지 나온 내용을 종합해 보면, 동적 배열에 n개의 데이터를 연속으로 추가하면:

1. 새로운 데이터를 저장하는 데에는 n의 시간이 들고
2. 데이터를 옮겨 저장하는 데에는 2n보다 적은 시간이 걸린다.

이 두 시간을 합치면 총 드는 시간은 3n보다 적은 시간이다. 이걸 시간 복잡도로 표현하면 O(3n), 그러니까 O(n)이라고 할 수 있다.

근데 이건 추가 연산을 한 번 하는 게 아니라 연속으로 n번 하는 데 걸리는 시간 복잡도이다.

그러니까, 총 n번의 추가 연산을 하는 데 걸리는 시간이 O(n)인 것이다. 추가 연산을 n번 하는 데 O(n)의 시간이 걸리니까 1번 하는 데는, O(n) / n, 즉 O(1)이 걸리는 것이다.

전에는 추가 연산이 최악의 경우 O(n)이 걸린다고 했었는데, 분할 상환 분석을 하면 O(1)이 걸린다고 보는 것이다.

<h4>최악의 경우 분석 vs. 분할 상환 분석</h4>

사실 분할 상환 분석을 한다고 꼭 시간 복잡도가 줄어드는 건 아니다. 보통은 할부 개념을 적용해도 시간 복잡도가 줄어들지 않는다.

하지만 만약 최악의 경우보다 분할 상환 분석을 한 시간 복잡도가 더 적다면, 분할 상환 분석을 한 시간 복잡도를 사용한다. 그러니까 "동적 배열의 끝에 데이터를 추가할 때는 O(1)이 걸린다." 라고 표현해도 된다는 것이다.

보통은 혼란을 없애기 위해 좀 더 정확하게:

<b>동적 배열의 추가(append) 연산은 최악의 경우 O(n)이 걸리지만, 상환 분석을 하면 O(1)이 걸린다.</b>

라고 표현할 수 있다.

<h3>동적 배열 삽입 연산</h3>

1. 정적 배열에 남는 공간이 있을 때

- 들어갈 자리 뒤에 있는 요소들을 전부 한 인덱스씩 뒤로 미뤄야 함
- 이 때 시간 복잡도는, [0]에 요소를 삽입할 때 현재 저장돼 있는 n개의 요소들을 전부 한 칸 뒤로 미뤄야 함. -> O(1) \* n = O(n)

2. 정적 배열이 꽉 찼을 때

- 새로운 배열을 만든 후 기존 배열을 복사해 줌. 그 후에 1. 처럼 들어갈 자리 뒤 요소들을 전부 한 인덱스씩 뒤로 미룸
- 이 때 시간 복잡도는
  - 새로운 배열을 만들고 기존요소를 옮겨 저장하는 시간 O(n)
  - 원하는 위치 뒤 요소들을 전부 한 칸 뒤로 미뤄줌. 최악의 경우 인덱스 0번이므로 n개를 뒤로 미뤄줘야 해서 O(n)
  - 새로운 데이터 넣기: O(1)
  - 총합 = O(n) + O(n) + O(1) = O(2n+1) = O(n)

결국 두 개의 삽입 연산의 시간 복잡도는 모두 O(n)임. 아무 위치에 삽입하기만 하면 O(n)이 걸림

<h3>동적 배열 삭제 연산</h3>

<h4>삭제 연산 동작</h4>

2, 3, 5, 7, 11이 있는 동적 배열에서 [1] = 3을 지우고 싶다고 했을 때, 한 단계씩 보자.

1. [1] 뒤에 있는 데이터를 모두 한 칸씩 앞으로 밀어서 저장한다.
   1. [1]에 [2]에 있던 5 저장
   2. [2]에 [3]에 있던 7 저장
   3. [3]에 [4]에 있던 11 저장
2. 동적 배열은 배열의 크기와 개발자가 사용하는 인덱스들의 범위를 따로 관리한다. 데이터를 삭제했으므로 동적 배열에서 접근할 수 있는 인덱스 범위도 1을 줄여 준다.

동적 배열에 남은 데이터는 2, 5, 7, 11이다.

요약하자면, 삭제 연산은 그냥 삭제하고 싶은 데이터 뒤에 있는 모든 데이터 요소들을 한 칸씩 앞으로 밀어서 저장하면 된다.

<h4>삭제 연산 시간 복잡도</h4>

삭제 연산 또한 아무 위치의 데이터를 삭제할 때와 맨 뒤 데이터를 삭제할 때, 두 경우를 나눠서 생각할 수 있다.

<h5>맨 앞 데이터를 지울 때(최악의 경우)</h5>

이 때 삭제 연산이 가장 오래 걸린다.

가장 앞 데이터를 삭제할 때는 [1]부터 끝까지 모든 요소들을 한 칸씩 앞으로 밀어서 저장해야 한다. 그러니까 삭제하기 전 배열 안에 총 n개의 데이터가 남아 있으면, 총 n-1개의 요소들을 하나씩 앞칸으로 밀어서 저장해야 된다는 것이다. 이 횟수가 n에 비례하므로 O(n)이 걸린다고 할 수 있다.

<h5>맨 뒤 데이터를 지울 때</h5>

그냥 동적 배열의 사용 공간을 한 인덱스 줄이면 된다. 배열의 데이터 요소 개수에 무관하게 일정한 시간에 (O(1)) 할 수 있다.
