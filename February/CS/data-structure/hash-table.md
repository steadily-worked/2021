# 자료구조

순서가 없는 key-value 데이터. 하나의 key와 그 key에 해당하는 value를 저장하는 방법

### Direct Access Table

인덱스를 `key`로 생각하고 데이터를 저장

<img width="814" alt="스크린샷 2021-02-11 오후 4 30 02" src="https://user-images.githubusercontent.com/61453718/107611038-6b818580-6c86-11eb-858d-365e578f4545.png">

이 때, 예를 들어 101호에 누가 사는 지 알고 싶을 경우 인덱스 101에 접근하면 됨. `key`(인덱스)를 이용한 `value` 접근: O(1) 만큼의 시간 복잡도 소요

단 이 경우, 낭비되는 인덱스가 상당히 많다.

<img width="815" alt="스크린샷 2021-02-11 오후 4 33 26" src="https://user-images.githubusercontent.com/61453718/107611237-e185ec80-6c86-11eb-80b8-e99158abc3ee.png">

## 해시 테이블

해시 함수: 특정 값을 원하는 범위의 자연수로 바꿔주는 함수
ex) [101, 204, 302, 711, 942] -> (0~100사이 자연수로 바꿔주는 함수) -> [20, 30, 90, 5, 80]

<img width="817" alt="스크린샷 2021-02-11 오후 4 38 18" src="https://user-images.githubusercontent.com/61453718/107611535-8e606980-6c87-11eb-91f3-081f51e3ee8c.png">

원하는 인덱스에 기존 인덱스와 값을 저장한다. (`key` + `value`)

원하는 값을 불러오고 싶을 때는,

<img width="816" alt="스크린샷 2021-02-11 오후 4 40 33" src="https://user-images.githubusercontent.com/61453718/107611679-ded7c700-6c87-11eb-8e1f-d7e921744c07.png">

해시 함수에 711을 넣으면 30이 리턴된다. 그 후 배열에 인덱스 30에 접근하고, 저장된 값을 가져온다.

<b>해시 테이블(Hash Table)</b>

1. 고정된 크기의 배열을 만들고
2. 해시 함수를 이용해서 `key`를 원하는 범위의 자연수로 바꾼다.
3. 해시 함수 결과 값 인덱스에 `key-value` 쌍을 저장한다.

### 해시 함수의 조건

```
101호: 최지웅
204호: 강영훈
302호: 성태호
711호: 김현승
942호: 손동욱
```

1. 한 해시 테이블의 해시 함수는 결정론적이어야 한다.

- 똑같은 key를 넣었을 때는 항상 똑같은 결과가 나와야 한다는 것이다. 942를 해시 함수에 넣을 때 어쩔 때는 5가 나오고 어쩔 때는 10이 나오고 이러면 안된다는 것이다. 942를 넣으면 항상 똑같은 결과가 나와야 한다.

2. 결과 해시값이 치우치지 않고 고르게 나온다.

- 해시 함수에 101, 204, 302, 711, 942나 아무 숫자를 넣었을 때 항상 40만 나오면 안 된다는 것이다. 원하는 범위가 0~100의 자연수라면, 이 사이에 아무 두 숫자가 나올 확이 최대한 비슷해야 한다.

3. 빨리 계산할 수 있어야 한다.

- 해시 테이블은 모든 연산을 할 때마다 해시 함수를 써야 되는데, 해시 함수가 비효율적이면 해시 테이블도 비효율적일 수밖에 없다.

### 해시 함수를 만드는 두 가지 방법

#### 나누기 방법

가장 직관적이며 쉬운 방법임. 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 함수. 예를 들어 저장해야 되는 키가 40, 120, 788, 2307이고 배열 크기가 200이라고 해보자. 그럼 그냥 key를 200으로 나눠서 남는 나머지를 리턴한다는 것이다. 40을 넣으면 40, 120은 120, 788은 188, 2307은 107이 리턴된다.

```python
def hash_function_remainder(key, array_size):
    """해시 테이블의 key를 나누기 방법으로 `0 ~ array_size - 1` 범위의 자연수로 바꿔주는 함수"""
    return key % array_size

print(hash_function_remainder(40, 200))
print(hash_function_remainder(120, 200))
print(hash_function_remainder(788, 200))
print(hash_function_remainder(230, 200))
```

결과

```
40
120
188
107
```

어떤 키가 들어와도 `0 ~ 원하는 정수` 범위의 자연수로 바꿔준다.

#### 곱셈 방법

나누기 방법보다 살짝 더 까다롭다.

예시) `key`: 200, 배열 크기: 30

1. `0 < a < 1`인 아무 값 `a`를 정한다. 임의로 0.666이라고 하자.
2. 그다음에 `a`에 `key`를 곱한다. 0.666에 200을 곱하면 133.32가 되는데, 이 때 정수 부분은 버리고 소수 부분만 남긴다. 그렇게 되면 0.32가 남는다.
3. 마지막으로 남은 소수 부분에 배열의 크기를 곱해준다. 0.32 \* 30 하면 9.6이 된다. 이번엔 소수점 부분을 버리고 9만 남긴다.

왜 이 방법이 원하는 범위의 자연수를 리턴할까? `a`와 `key`를 곱한 값의 정수 부분을 버리면 그 결과 값은 `0.xxxx` 이런 식으로 0과 1 사이의 소수가 나올 수밖에 없다. 0과 1 사이의 소수에 테이블의 크기를 곱해버리면, 다시 0과 테이블 크기 사이의 수가 나온다. 0.0001에 테이블 크기 30을 곱하면 0.003이 나오고, 0.9999에 테이블 크기 30을 곱하면 29.997이 나온다. 항상 0보다 크거나 같고 테이블 크기인 30보단 작은 숫자가 나온다. 그리고 여기서 소수점 뒷자리를 버리므로 원하는 범위의 자연수를 구할 수 있다.

코드로 나타내면,

```python
def hash_function_multiplication(key, array_size, a):
    """해시 테이블의 key를 곱셈 방법으로 `0 ~ array_size - 1` 범위의 자연수로 바꿔주는 함수"""
    temp = a * key
    temp = temp - int(temp) # a와 key를 곱한 값의 소숫점 오른쪽 부분만 저장한다.

    return int(array_size * temp) # temp와 배열 크기를 곱한 수의 자연수 부분만 리턴한다.

print(hash_function_multiplication(40, 200, 0.61426212))
print(hash_function_multiplication(120, 200, 0.61426212))
print(hash_function_multiplication(788, 200, 0.61426212))
print(hash_function_multiplication(2307, 200, 0.61426212))
```

결과

```
114
142
7
20
```

정리

- 나눗셈: key % 배열의 크기
- 곱셈: `임의의 값 * key`의 소수 부분 \* `배열의 크기`를 한 후 소숫점 버림

### Python hash 함수

파이썬 언어도 내부적으로 `hash`라는 함수를 제공한다. 파이썬 해시 함수는 파라미터로 받은 값을 그냥 아무 정수로만 바꿔주는 함수이다. <b>특정 범위가 아닌, 아무 정수로만</b> 바꿔주는 것이다

```python
# 정수 값
print(hash(12345)) # 12345
print(hash(12345)) # 12345

# 다른 정수 값
print(hash(12346)) # 12346

# 소수 값
print(hash(15.1234))  # 284541027336970255
print(hash(15.1234))  # 284541027336970255

# 다른 소수 값
print(hash(81.1234))  # 284541027336978513

# 문자열
print(hash("파이썬"))  # -8002119629611903017
print(hash("파이썬"))  # -8002119629611903017

# 다른 문자열
print(hash("자바"))  # -8553573703343279427
```

여기서 중요한 점은, 서로 다른 두 값을 파라미터로 넣었을 때 같은 정수가 리턴될 수 없다는 것, 즉 데이터를 자신만의 고유한 정수 값으로 바꿔준다는 것이다. 지금까지 해시 함수의 key를 정수형으로만 생각했었는데, 다른 타입의 데이터들을 자신만의 고유한 정수 값으로 바꿀 수 있으면 이제 정수 뿐만 아니라 다른 자료형들도 key로 사용할 수 있다.

#### 한계

파이썬 `hash` 함수는 자체적으로는 불변 타입 자료형에만 사용할 수 있다.

- 불린형
- 정수형
- 소수형
- 튜플
- 문자열

해당 타입의 자료형만 `hash` 함수의 파라미터로 넘겨줄 수 있다.

### 해시 테이블 충돌과 Chaining 개념

만약 서로 다른 key가 해시 함수를 통해 같은 값을 가질 경우엔 어떻게 해야 할까? -> 이때 `충돌(collision)`이 일어났다고 한다.

Chaining: 배열 인덱스에 링크드 리스트를 저장해서 충돌을 해결하는 방법을 의미. 이를 통해 해시 테이블에서 충돌이 일어나도 key-value 쌍들을 모두 저장할 수 있다.

기존 링크드 리스트를 Chaining을 이용해서 바꿔볼 수 있다.

#### Node 클래스

여기선 크게 바꿀 건 없고, 링크드 리스트 노드가 변수 `data` 대신에 `key`와 `value`를 저장하도록 한다.

```Python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None # 다음 노드에 대한 레퍼런스
        self.prev = None # 전 노드에 대한 레퍼런스
```

#### LinkedList 클래스

링크드 리스트 클래스에서는 필요한 메소드들만 가지고 와서 쓰면 된다. 노드 클래스랑 마찬가지로 그대로 사용할 순 없고, 조금씩 고쳐서 써야 한다.

`__init__` 메소드는 그대로이다.

```Python
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None # 링크드 리스트의 가장 앞 노드
        self.tail = None # 링크드 리스트의 가장 뒤 노드
```

##### 탐색 메소드

```Python
def find_node_with_key(self, key):
    """링크드 리스트에서 주어진 데이터를 갖고 있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head # 링크드 리스트를 돌기 위해 필요한 노드 변수

    while iterator is not None:
        if iterator.key == key:
            return iterator
```
