# 자료구조

## 힙 (heap)

두 가지 조건을 만족하는 자료 구조이다.

1. 형태 속성: 힙은 완전 이진 트리여야 한다.

<img width="814" alt="스크린샷 2021-02-18 오후 9 29 18" src="https://user-images.githubusercontent.com/61453718/108357151-65fce000-7230-11eb-9ead-d4bd47bb7aa1.png">

2. 힙 속성: 힙 내에 있는 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같아야 한다.

<img width="815" alt="스크린샷 2021-02-18 오후 9 30 42" src="https://user-images.githubusercontent.com/61453718/108357279-8fb60700-7230-11eb-8ef4-4415b4239d32.png">

힙을 통해 정렬 문제를 해결할 수 있고(`11, 2, 5, 7, 3` -> `2, 3, 5, 7, 11`),

또한 우선순위 큐를 구현할 수 있다.

### 정렬

여러 개의 데이터 요소들을 특정 순서로 배치하는 것

ex) `[4, 1, 6, 2, 8, 5]`인 파이썬 리스트

1. 오름차순 배치 -> `[1, 2, 4, 5, 6, 8]`
2. 내림차순 배치 -> `[8, 6, 5, 4, 2, 1]`

- 정렬 알고리즘: 데이터를 재배치하는 구체적인 방법

  - 삽입 정렬
  - 선택 정렬
  - 퀵 정렬
  - 합병 정렬

### 배열로 구현한 힙

- 완전 이진 트리이므로 동적 배열로 구현한다.

<img width="815" alt="스크린샷 2021-02-20 오후 8 50 45" src="https://user-images.githubusercontent.com/61453718/108594430-54950e80-73bd-11eb-9bdc-035617fb60a1.png">

해당 힙은 파이썬 리스트로 이렇게 구현이 된 것이다. 한 인덱스가 한 노드를 나타낸다.

`왼쪽 자식 인덱스: 인덱스 * 2`, `오른쪽 자식 인덱스: 인덱스 * 2 + 1`

### 힙 만들기

<img width="818" alt="스크린샷 2021-02-20 오후 8 53 50" src="https://user-images.githubusercontent.com/61453718/108594505-bd7c8680-73bd-11eb-931c-9d20cc3eb5c7.png">

이 트리는 힙일까? 힙이 되기 위해서는 두 가지 조건을 만족해야 한다.

1. 형태 속성: 이 트리가 완전 이진 트리인가?의 여부

   - 마지막 레벨 빼고 다 채워져 있고, 마지막 레벨도 왼쪽부터 오른쪽 방향으로 채워져 있으므로 완전 이진 트리가 맞다. -> 형태 속성 충족

2. 힙 속성: 부모 노드가 자식 노드보다 큰 값을 가져야 한다.
   - 노드 2의 데이터는 자식들의 데이터보다 작으므로 충족하지 못함.

따라서 힙이 아니다.

부모 노드보다 자식 노드가 더 클 경우 그 두 노드를 바꿔주면 된다. (`heapify`)

부모 노드, 왼쪽 자식, 오른쪽 자식 중 가장 큰 노드를 고른다. 가장 큰 노드가 부모 노드가 아니라면 부모 노드와 해당 노드를 바꿔준다. 이런 방식으로 `heapify`를 해줘서 힙의 조건을 충족할 때까지 반복한다.

#### 시간 복잡도

<img width="816" alt="스크린샷 2021-02-21 오후 1 34 09" src="https://user-images.githubusercontent.com/61453718/108615635-7fc53f80-7449-11eb-88f2-f203db629031.png">

이미지에서처럼 최악의 경우는, `root` 노드가 계속 내려가서 `leaf` 노드까지 내려가는 경우이다.

힙은 완전 이진 트리이기 때문에 높이가 `O(log(n))`이다. 최악의 경우 `heapify`에 걸리는 시간은 `O(log(n))`에 비례하므로 시간 복잡도 또한 `O(log(n))`이다.
