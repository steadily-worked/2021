# 자료구조

## 힙 (heap)

두 가지 조건을 만족하는 자료 구조이다.

1. 형태 속성: 힙은 완전 이진 트리여야 한다.

<img width="814" alt="스크린샷 2021-02-18 오후 9 29 18" src="https://user-images.githubusercontent.com/61453718/108357151-65fce000-7230-11eb-9ead-d4bd47bb7aa1.png">

2. 힙 속성: 힙 내에 있는 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같아야 한다.

<img width="815" alt="스크린샷 2021-02-18 오후 9 30 42" src="https://user-images.githubusercontent.com/61453718/108357279-8fb60700-7230-11eb-8ef4-4415b4239d32.png">

힙을 통해 정렬 문제를 해결할 수 있고(`11, 2, 5, 7, 3` -> `2, 3, 5, 7, 11`),

또한 우선순위 큐를 구현할 수 있다.

### 정렬

여러 개의 데이터 요소들을 특정 순서로 배치하는 것

ex) `[4, 1, 6, 2, 8, 5]`인 파이썬 리스트

1. 오름차순 배치 -> `[1, 2, 4, 5, 6, 8]`
2. 내림차순 배치 -> `[8, 6, 5, 4, 2, 1]`

- 정렬 알고리즘: 데이터를 재배치하는 구체적인 방법

  - 삽입 정렬
  - 선택 정렬
  - 퀵 정렬
  - 합병 정렬

### 배열로 구현한 힙

- 완전 이진 트리이므로 동적 배열로 구현한다.

<img width="815" alt="스크린샷 2021-02-20 오후 8 50 45" src="https://user-images.githubusercontent.com/61453718/108594430-54950e80-73bd-11eb-9bdc-035617fb60a1.png">

해당 힙은 파이썬 리스트로 이렇게 구현이 된 것이다. 한 인덱스가 한 노드를 나타낸다.

`왼쪽 자식 인덱스: 인덱스 * 2`, `오른쪽 자식 인덱스: 인덱스 * 2 + 1`

### 힙 만들기

<img width="818" alt="스크린샷 2021-02-20 오후 8 53 50" src="https://user-images.githubusercontent.com/61453718/108594505-bd7c8680-73bd-11eb-931c-9d20cc3eb5c7.png">

이 트리는 힙일까? 힙이 되기 위해서는 두 가지 조건을 만족해야 한다.

1. 형태 속성: 이 트리가 완전 이진 트리인가?의 여부

   - 마지막 레벨 빼고 다 채워져 있고, 마지막 레벨도 왼쪽부터 오른쪽 방향으로 채워져 있으므로 완전 이진 트리가 맞다. -> 형태 속성 충족

2. 힙 속성: 부모 노드가 자식 노드보다 큰 값을 가져야 한다.
   - 노드 2의 데이터는 자식들의 데이터보다 작으므로 충족하지 못함.

따라서 힙이 아니다.

부모 노드보다 자식 노드가 더 클 경우 그 두 노드를 바꿔주면 된다. (`heapify`)

부모 노드, 왼쪽 자식, 오른쪽 자식 중 가장 큰 노드를 고른다. 가장 큰 노드가 부모 노드가 아니라면 부모 노드와 해당 노드를 바꿔준다. 이런 방식으로 `heapify`를 해줘서 힙의 조건을 충족할 때까지 반복한다.

#### 시간 복잡도

<img width="816" alt="스크린샷 2021-02-21 오후 1 34 09" src="https://user-images.githubusercontent.com/61453718/108615635-7fc53f80-7449-11eb-88f2-f203db629031.png">

이미지에서처럼 최악의 경우는, `root` 노드가 계속 내려가서 `leaf` 노드까지 내려가는 경우이다.

힙은 완전 이진 트리이기 때문에 높이가 `O(log(n))`이다. 최악의 경우 `heapify`에 걸리는 시간은 `O(log(n))`에 비례하므로 시간 복잡도 또한 `O(log(n))`이다.

### 힙 만들기 II

heapify: 파라미터로 넘기는 노드가 힙에서 위치를 찾아간다. 노드 10부터 1까지 순서대로 넣어서 호출하면 어떻게 될까?

<img width="811" alt="스크린샷 2021-02-22 오후 3 47 22" src="https://user-images.githubusercontent.com/61453718/108672337-43ffa800-7525-11eb-810a-c7cbf69fc2b3.png">

노드 6~10까지는 `leaf node`이므로 `heapify`를 통해 바뀌는 게 없다. 5부터는 가정을 해야 한다.

<img width="804" alt="스크린샷 2021-02-22 오후 3 49 30" src="https://user-images.githubusercontent.com/61453718/108672527-8f19bb00-7525-11eb-92f3-421c4f4b07b6.png">

노드 2의 이전 노드까지는 `heapify`가 되어 있기 때문에 이미 힙 속성을 지키고 있다고 할 수 있다. 이 부분에서 노드 2에 `heapify`를 해준다면..

<img width="804" alt="스크린샷 2021-02-22 오후 3 51 09" src="https://user-images.githubusercontent.com/61453718/108672637-ca1bee80-7525-11eb-94b7-5812a7bfe74a.png">

다음과 같이 노드 2와 그 아래 모든 노드들이 힙 속성을 가지게 된다.

<img width="804" alt="스크린샷 2021-02-22 오후 3 51 59" src="https://user-images.githubusercontent.com/61453718/108672726-e750bd00-7525-11eb-92cc-2ad48241c117.png">

1을 제외한 모든 노드들에 대해 `heapify`를 해줬기 때문에, 다음과 같이 모든 노드가 이미 힙 속성을 지키고 있게 된다. 이제 `root`에 `heapify`를 해 주면,

<img width="814" alt="스크린샷 2021-02-22 오후 3 53 00" src="https://user-images.githubusercontent.com/61453718/108672833-0bac9980-7526-11eb-9841-f99610cd2918.png">

모든 노드가 힙 속성을 갖고 있으므로, `힙을 만들었다` 라고 할 수 있게 되는 것이다.

<img width="814" alt="스크린샷 2021-02-22 오후 3 53 00" src="https://user-images.githubusercontent.com/61453718/108672833-0bac9980-7526-11eb-9841-f99610cd2918.png">

정리하자면, 마지막 노드부터 반대 순서로 `heapify`를 해주면 힙으로 만들 수 있는 것이다.

#### 시간 복잡도

힙을 만드는 데 걸리는 시간은?

<img width="814" alt="스크린샷 2021-02-22 오후 3 55 41" src="https://user-images.githubusercontent.com/61453718/108673098-6ba34000-7526-11eb-9034-0f2fcc292898.png">

한 번 `heapify`할 때 걸리는 시간은 `O(log(n))`인데, 모든 `n`개의 노드에 대해 `heapify`를 하므로, 총 걸리는 시간은 `O(nlog(n))`이 된다.

### 힙 정렬

> 힙을 이용한 정렬 알고리즘

<img width="815" alt="스크린샷 2021-02-22 오후 3 57 37" src="https://user-images.githubusercontent.com/61453718/108673236-b0c77200-7526-11eb-93ba-4fafeb4eecca.png">

`root` 노드와 노드 10을 바꿔줬다고 해보자. 그럼 위와 같은 형태로 바뀐다. 힙 속성이 망가진 것이다. 힙 속성을 맞추기 위해 `root` 노드에 `heapify`를 호출한다.

이 때, **노드 10은 없는 노드 취급을 해줘야 한다.** 데이터가 저장되어 있긴 하지만 없는 것처럼 무시해야 한다.

<img width="814" alt="스크린샷 2021-02-22 오후 3 59 07" src="https://user-images.githubusercontent.com/61453718/108673378-e704f180-7526-11eb-801c-91d4ee210a70.png">

`heapify`를 해 주면, **노드 10을 제외하고** 힙 속성을 충족하는 힙이 완성된다. `root` 노드에 12가 저장돼 있다.

<img width="814" alt="스크린샷 2021-02-22 오후 4 01 05" src="https://user-images.githubusercontent.com/61453718/108673539-2cc1ba00-7527-11eb-94cd-b24731ca58b7.png">

이번에도 `root` 노드를 노드 9와 바꿔준다. 이렇게 한 후 마찬가지로 `heapify`를 해 주면, **노드 10과 9를 제외하고** 힙 속성을 충족하는 힙이 완성된다.

이런 방식으로 계속 마지막 노드와 바꿔준 후 의도적으로 망가뜨린 힙 속성을 다시 충족해주기 위해 `heapify`를 반복하게 되면..

<img width="812" alt="스크린샷 2021-02-22 오후 4 03 07" src="https://user-images.githubusercontent.com/61453718/108673698-75797300-7527-11eb-9501-49df271799eb.png">

결국 이렇게 값 순서대로 저장된 트리가 완성된다. 데이터가 오름차순으로 정렬된다. 이러한 방식이 바로 **힙 정렬**이다.

이를 일반화해서 표현해보면:

`힙을 만든다` -> `root 노드와 마지막 노드를 바꿔준다.` -> `(바꾼 노드는 없는 노드로 취급한다)` -> `새로운 노드가 힙 속성을 지킬 수 있게 heapify를 호출한다`

여기서 2~4번째 순서를 반복해주는 것이다.

**만약 내림차순으로 정렬하고 싶을 경우?**

    - 힙 속성을 반대로 바꾸고(자식 노드의 데이터가 부모 노드의 데이터보다 커야 한다) 똑같은 알고리즘을 적용하면 된다.
