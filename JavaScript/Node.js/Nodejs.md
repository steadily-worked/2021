<Node.js 교과서 개정 2판>을 정리함과 동시에 제 나름대로의 생각을 적은 글입니다.

# Node.js

## 1. 노드 시작하기

1장에서는 노드(`Node.js`)가 무엇인업, 어디에 쓰이는지, 누가 쓰는지 알아보고, 노드의 핵심 개념을 배운다.

### 1-1. 핵심 개념 이해하기

노드 공식 사이트에서는 노드를 다음과 같이 설명하고 있다.

> Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다.

우선, 서버와 런타임이 무엇인지부터 알아보자.

#### 1-1-1. 서버

노드를 통해 다양한 자바스크립트 어플리케이션을 실행할 수 있지만, 노드는 서버 어플리케이션을 실행하는 데 제일 많이 사용한다.

그럼 서버란 무엇이며, 어떤 역할을 할까? 서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말한다. 클라이언트란 요청을 보내는 주체로 브라우저일 수도 있고, 데스크탑 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있다. 평소 사용하는 웹 사이트나 앱을 생각해보자. 웹 사이트의 화면(`HTML`)은 어디서 가져올까? 앱 설치 파일은 어디에서 내려받는 것일까?

예를 들어 네이버를 방문한다고 해 보자. 주소창에 네이버의 웹 사이트 주소(https://www.naver.com)을 입력(요청)하면, 브라우저는 그 주소에 해당하는 네이버의 컴퓨터 위치를 파악한다. 그리고 그 컴퓨터로부터 네이버의 웹 사이트 페이지를 받아와서 요청자의 브라우저(클라이언트)에 띄운다(응답). 이런 일을 하는 컴퓨터가 바로 서버이다.

모바일 앱을 설치하는 경우를 생각해보자. 구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누르면(요청) 내려받기(응답)가 시작된다. 앱 설치 파일은 이미 어딘가에 저장되어 있으므로 여러분이 그곳에서 데이터를 받아와 모바일 기기에 설치할 수 있는 것이다. 그 어딘가가 구글과 애플의 서버이다. 플레이 스토어와 앱스토어는 클라이언트 역할을 하는 것이다.

웹이나 앱을 사용할 때 각자의 데이터(아이디, 비밀번호, 이메일 등)와 서비스의 데이터가 생성된다. 이 데이터를 어딘가에 저장하고, 그 어딘가에서 클라이언트로 데이터를 받아와야 한다. 이곳이 바로 서버이다.

서버라고 해서 요청에 대한 응답만 하는 것은 아니다. 다른 서버에 요청을 보낼 수도 있다. 이 때는 요청을 보낸 서버가 클라이언트 역할을 한다.

정리하면, 서버는 클라이언트의 요청에 대해 응답을 한다. 응답으로 항상 Yes를 해야 하는 것은 아니고, No를 할 수도 있다. 만약 본인이 어떤 사이트로부터 차단당했다면 그 사이트의 서버는 본인의 요청에 대해 매번 No를 응답할 것이다.

노드는 자바스크립트 프로그램이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있다. 왜 다른 언어를 사용하지 않고 굳이 노드를 사용해 서버를 만들까? 이 궁금증을 해결하려면 먼저 노드의 특성을 알아야 한다. 공식 웹 사이트에 게시된 노드 소개글을 바탕으로 노드의 특성을 알아보자.

#### 1-1-2. 자바스크립트 런타임

공식 사이트에 게시된 노드 소개글을 다시 한 번 보자.

> Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다.

노드는 자바스크립트 런타임이다. 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻한다. 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있다. 쉽게 말해 노드는 자바스크립트 실행기라고 봐도 무방하다. 따라서 본인이 자바스크립트를 모른다면 노드를 전혀 활용할 수 없다.

기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행할 수 있었다. 브라우저는 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있다. 브라우저 외의 환경에서 자바스크립트를 실행하기 위한 여러 시도가 있었으나, 자바스크립트의 실행 속도 문제 때문에 모두 큰 호응을 얻지는 못했다.

하지만 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하자 이야기가 달라졌다. 당시 V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐고, 오픈 소스로 코드를 공개했다. 속도 문제가 해결되자 라이언 달(Ryan Dahl)은 2009년 V8 엔진 기반의 노드 프로젝트를 시작했다.

노드는 V8과 더불어 libuv라는 라이브러리를 사용한다. V8과 libuv는 `C`와 `C++`로 구현되어 있다. 본인이 코딩한 자바스크립트 코드는 노드가 알아서 V8과 libuv에 연결해주므로, 노드를 사용할 때 `C`와 `C++`은 몰라도 된다.

libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있다. 이 모델이 무엇이고 어떤 장단점들이 있는지 알아보자.

#### 1-1-3. 이벤트 기반

이벤트 기반(`event-driven`)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있다.

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해둬야 한다. 이를 이벤트 리스너(`event listenenr`)에 콜백(`callback`) 함수를 등록한다고 표현한다. 버튼을 클랙할 때 경고창을 띄우도록 설정하는 것을 예로 들어보자. 클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수를 등록해두면 클릭 이벤트가 발생할 때마다 콜백 함수가 실행되어 경고창이 뜨는 것이다.

노드도 이벤트 기반형식으로 동작하므로, 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출한다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, 노드는 다음 이벤트가 발생할 때까지 기다린다.

이벤트 기반 모델에서는 이벤트 루프(`event loop`)라는 개념이 등장한다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다.

특정 밀리초(1/1000초) 이후에 코드를 실행하는 `setTimeout`을 사용해 보자. 콘솔에 어떤 로그가 기록될지 예측해보자.

```js
run = () => {
  console.log("3초 후 실행");
};
console.log("시작");
setTimeout(run, 3000);
console.log("끝");
```

결과는 다음과 같다.

```
시작
끝
3초 후 실행
```

3초 뒤에 `run` 함수를 실행하는 코드이다. 콘솔 결과는 쉽게 예측할 수 있지만, 호출 스택으로 설명하기는 어렵다. `setTimeout` 함수의 콜백인 `run`이 호출 스택에 언제 들어가는지 지금까지 배운 내용으로는 쉽게 파악할 수 없기 때문이다. 이를 파악하기 위해서는 이벤트 루프, 태스크 큐(`task queue`), 백그라운드(`background`)를 알아야 한다. 다음은 기술적으로 정확히 설명하기보단 이해를 돕기 위해 추상화해서 설명한 내용이다.

- 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(`loop`)라고 부른다.

- 백그라운드: `setTimeout` 같은 타이머나 이벤트 리스너들이 대기하는 곳이다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 된다. 여러 작업이 동시에 실행될 수 있다.

- 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부른다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 한다.

위 코드가 실행되는 내부 과정을 보자.

먼저, 전역 컨텍스트인 `anonymous`가 호출 스택에 들어간다. 그 뒤 `setTimeout`이 호출 스택에 들어간다.

호출 스택에 들어간 순서와 반대로 실행되므로, `setTimeout`이 먼저 실행된다. `setTimeut`이 실행되면 타이머와 함께 `run` 콜백을 백그라운드로 보내고, `setTimeout`은 호출 스택에서 빠진다. 그다음으로 `anonymous`가 호출 스택에서 빠진다. 백그라운드에서는 3호를 센 후 `run` 함수를 태스크 큐로 보낸다. 3초를 셌다는 것은 백그라운드에 맡겨진 작업이 완료된 것으로 이해해도 된다. 이런 식으로 이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부른다.

이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행한다. 호출 스택으로 올려진 `run`은 실행되고, 실행 완료 후 호출 스택에서 비워진다. 이벤트 루프는 태스크 큐에 콜백 함수가 들어올 때까지 계속 대기한다.

만약 호출 스택에 함수들이 너무 많이 들어 있으면 3초가 지난 후에도 `run` 함수가 실행되지 않을 수 있다. 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 `run` 함수를 호출 스택으로 가져오기 때문이다. 이것이 `setTimeout`의 시간이 정확하지 않을 수도 있는 이유이다.

#### 1-1-4. 논 블로킹 I/O

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다. 작업에는 두 가지 종류가 있는데, 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이다. 기본적으로 각자가 작성한 자바스크립트 코드는 동시에 실행될 수 없다. 하지만 자바스크립트상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있다.

I/O는 입력(`input`)/출력(`output`)을 의미한다. 파일 시스템 접근(파일 읽기, 파일 쓰기, 폴더 만들기 등)이나 네트워크를 통한 요청 같은 작업이 I/O의 일종이다. 이러한 작업을 할 때 노드는 논 블로킹 방식으로 처리하는 방법을 제공한다. **논 블로킹**이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 **블로킹**은, 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 보통 블로킹 방식보다, 논 블로킹 방식이 같은 작업을 더 짧은 시간에 처리할 수 있다. 다만, 작업들이 모두 동시에 처리될 수 있는 작업이라는 전제가 있다.

노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 한다. 따라서 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다.

예를 들어 처리하는 데 1초가 걸리는 작업 다섯 개가 있다고 해 보자. 그 중 세 개는 동시에 처리할 수 있고 두 개는 동시에 처리할 수 없다. 각자를 나열하여 그 순서대로 작업하는 경우는 5초 정도가 소요될 것이고, 동시 처리가 가능한 세 개를 한꺼번에 처리하고 아닌 것들을 각각 병렬적으로 배치하면, 순서만 바꿨을 뿐인데 3초 정도로 작업 시간이 단축된다.

이렇게 작업 순서에 따라 성능이 크게 달라진다. 동시에 처리될 수 있는 I/O 작업이라도 논블로킹 방식으로 코딩하지 않으면 의미가 퇴색되므로 논 블로킹 방식으로 코딩하는 습관을 들여야 한다.

```js
longRunningTask = () => {
  // 오래 걸리는 작업
  console.log("작업 끝");
};

console.log("시작");
longRunningTask();
console.log("다음 작업");
```

작업을 수행하는 데 오래 걸리는 `longRunningTask` 함수가 있고, 이 함수가 블로킹 방식의 I/O 작업을 한다고 생각해 보자. 이 작업이 완료되기 전까지는 이어지는 `console.log("다음 작업");`이 호출되지 않는다.

이번에는 setTimeout을 사용해서 코드를 바꿔보자.

```js
longRunningTask = () => {
  // 오래 걸리는 작업
  console.log("작업 끝");
};
console.log("시작");
setTimeout(longRunningTask, 0);
console.log("다음 작업");
```

결과는 다음과 같다.

```
시작
다음 작업
작업 끝
```

`setTimeout(콜백, 0)`은 코드를 논 블로킹으로 만들기 위해 사용하는 기법 중 하나이다. 사실 노드에서는 `setTimeout(콜백, 0)` 대신 다른 방식을 주로 사용하긴 한다(3.4.3의 `setImmediate` 참조). 이벤트 루프를 이해했다면 `setTimeout`의 콜백 함수인 `longRunningTask`가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있다. 다음 작업이 먼저 실행된 이후, 오래 걸리는 작업이 완료된다.

다만, 아무리 논 블로킹 방식으로 코드를 작성하더라도 코드가 전부 각자가 작성한 것이라면 전체 소요 시간이 짧아지지는 않는다. 각자의 코드는 서로 동시에 실행되지 않기 때문이다. 단순히 실행 순서만 바뀔 뿐이다. 위 예제에서는 `console.log('다음 작업')`과 `longRunningTask` 모두 각자가 작성한 코드이다.

그렇다고 I/O 작업이 없다고 해서 논 블로킹이 의미가 없는 것은 아니다. 오래 걸리는 작업을 처리해야 하는 경우, 논 블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있다. 또한, **논 블로킹**과 **동시**가 같은 의미가 아니라는 것도 알아두자. 동시성은 동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있다.

> setTimtout(콜백, 0)에서, 밀리초를 0으로 설정했으므로 바로 실행되는 것으로 착각할 수 있다. 하지만, 브라우저와 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않는다. HTML5 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있다.

블로킹과 논 블로킹 외에 동기와 비동기라는 개념도 들어봤을 것이다. 동기와 비동기, 블로킹과 논 블로킹의 관계는 3.6.1에서 코드와 함께 설명한다. 노드에서는 동기와 블로킹이 유사하고 비동기와 논 블로킹이 유사하다고만 알아두면 된다.

#### 1-1-5. 싱글 스레드

이벤트 기반, 논 블로킹 모델과 더불어 노드를 설명할 때 자주 나오는 용어가 하나 더 있다. 바로 싱글 스레드이다. 싱글 스레드란 스레드가 하나뿐이라는 것을 의미한다. 각자가 작성한 자바스크립트 코드가 동시에 실행될 수 없는 이유이기도 하다. 스레드를 이해하기 위해서는 프로세스부터 알아야 한다. 프로세스와 스레드의 차이는 다음과 같다.

- 프로세스는 운영체제에서 할당하는 작업의 단위이다. 노드나 웹 브라우저와 같은 프로그램은 개별적인 프로세스이다. 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있다. 스레드들은 부모 프로세스의 자원을 공유한다. 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있다.

노드가 싱글 스레드라는 말을 들어봤을 것이다. 하지만 엄밀히 말하면 싱글 스레드로 동작하지는 않는다. 노드를 실행하면 먼저 프로세스가 하나 생성된다. 그리고 그 프로세스에서 스레드들을 생성하는데, 이때 내부적으로 스레드를 여러개 생성한다. 그중에서 각자가 직접 제어할 수 있는 스레드는 하나뿐이다. 그래서 흔히 노드가 싱글 스레드라고 여겨지는 것이다.

스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 하나의 스레드만 직접 조작할 수 있으므로 일손이 하나인 셈이다. 요청이 많이 들어오면 한 번에 하나씩 요청을 처리한다. 블로킹이 심하게 일어나는 작업을 처리하지만 않는다면 스레드 하나로도 충분하다. 블로킹이 발생할 것 같은 경우에는 논 블로킹 방법으로 대기 시간을 최대한 줄인다.

> **스레드풀과 워커 스레드**
>
> 노드가 싱글 스레드로 동작하지 않는 두 가지 경우가 있다. 하나는 스레드풀(`Thread Pool`)이고, 다른 하나는 워커 스레드(`Worker Thread`)이다.
>
> 스레드풀은 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용한다. 대표적인 예로 암호화(3.5.5), 파일 입출력(3.6), 압축(3.6.2) 등이 있다.
>
> 워커 스레드는 노드 12 버전에서 안정화된 기능으로 이제 노드에서도 멀티 스레드를 사용할 수 있게 되었다. 각자가 직접 다수의 스레드를 다룰 수 있다. CPU 작업(연산이 많은 작업)이 많은 경우 워커 스레드를 사용하면 된다.

언뜻 보면 여러 개의 일을 동시에 처리할 수 있으므로 멀티 스레드가 싱글 스레드보다 좋아보인다. 하지만 꼭 그런 것은 아니다. 이해를 돕기 위해 하나의 예시를 들어 보겠다.

한 음식점에 점원이 한 명 있다. 손님은 여러 명이다. 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 한다. 그 후 다음 손님의 주문을 받는다. 이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못하고 기다려야 한다. 이것이 바로 싱글 스레드(점원), 블로킹 모델이다. 매우 비효율적이다.

이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받는다. 요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 사실만 주방에 계속 알려주는 것이다. 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙한다. 요리의 특성(블로킹인지 논 블로킹인지)에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서는 일치하지 않을 수도 있다.

이것이 싱글 스레드, 논 블로킹 모델이다. 바로 노드가 채택하고 있는 방식이다. 점원은 한 명이지만 혼자서 많은 일을 처리할 수 있다. 하지만 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가 생길 수 있다. 또한, 요리를 하는 데 시간이 오래 걸린다면(CPU를 많이 쓰는 작업) 주문이 많이 들어왔을 때 버거울 수 있다.

멀티 스레드 방식에서는 손님 한 명이 올 때마다 점원도 한 명씩 붙어 주문을 받고 서빙한다. 언뜻 보면 싱글 스레드보다 좋은 방법인 것 같지만, 장단점이 있다. 일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없다. 점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문이다. 하지만 손님의 수가 늘어날수록 점원의 수도 늘어난다. 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다는 것도 문제가 된다. 점원을 새로 고용하거나 기존 점원을 해고하는 데는 비용이 발생한다.

그렇다면 점원 여러 명(멀티 스레드)이 모두 논 블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 의문이 들 수 있다. 실제로 그렇다. 다만 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어려우므로 멀티 프로세싱 방식을 대신 사용한다. I/O 요청에는 멀티 프로세싱이 더 효율적이기도 하다.

| 멀티 스레딩                                  | 멀티 프로세싱            |
| -------------------------------------------- | ------------------------ |
| 하나의 프로세스 안에서 여러 개의 스레드 사용 | 여러 개의 프로세스 사용  |
| CPU 작업이 많을 때 사용                      | I/O 요청이 많을 때 사용  |
| 프로그래밍이 어려움                          | 프로그래밍이 비교적 쉬움 |

I/O 작업을 처리할 때는 멀티 스레딩보다 멀티 프로세싱이 효율적이므로 노드는 멀티 프로세싱을 많이 한다. 4.5의 cluser 모듈과 15.1.5의 pm2 패키지에서 멀티 프로세싱을 가능하게 하는 방법을 알아본다. 멀티 스레딩을 하는 방법은 3.5.7에서 알아본다.
