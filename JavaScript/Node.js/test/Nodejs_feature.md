<Node.js 교과서 개정 2판>을 정리함과 동시에 제 나름대로의 생각을 적은 글입니다.

# Node.js

## 1. 노드 시작하기

1장에서는 노드(`Node.js`)가 무엇인지, 어디에 쓰이는지, 누가 쓰는지 알아보고, 노드의 핵심 개념을 배운다.

### 1-1. 핵심 개념 이해하기

노드 공식 사이트에서는 노드를 다음과 같이 설명하고 있다.

> Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다.

우선, 서버와 런타임이 무엇인지부터 알아보자.

#### 1-1-1. 서버

노드를 통해 다양한 자바스크립트 어플리케이션을 실행할 수 있지만, 노드는 서버 어플리케이션을 실행하는 데 제일 많이 사용한다.

그럼 서버란 무엇이며, 어떤 역할을 할까? 서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말한다. 클라이언트란 요청을 보내는 주체로 브라우저일 수도 있고, 데스크탑 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있다. 평소 사용하는 웹 사이트나 앱을 생각해보자. 웹 사이트의 화면(`HTML`)은 어디서 가져올까? 앱 설치 파일은 어디에서 내려받는 것일까?

예를 들어 네이버를 방문한다고 해 보자. 주소창에 네이버의 웹 사이트 주소([https://www.naver.com](https://www.naver.com))을 입력(요청)하면, 브라우저는 그 주소에 해당하는 네이버의 컴퓨터 위치를 파악한다. 그리고 그 컴퓨터로부터 네이버의 웹 사이트 페이지를 받아와서 요청자의 브라우저(클라이언트)에 띄운다(응답). 이런 일을 하는 컴퓨터가 바로 서버이다.

모바일 앱을 설치하는 경우를 생각해보자. 구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누르면(요청) 내려받기(응답)가 시작된다. 앱 설치 파일은 이미 어딘가에 저장되어 있으므로 여러분이 그곳에서 데이터를 받아와 모바일 기기에 설치할 수 있는 것이다. 그 어딘가가 구글과 애플의 서버이다. 플레이 스토어와 앱스토어는 클라이언트 역할을 하는 것이다.

웹이나 앱을 사용할 때 각자의 데이터(아이디, 비밀번호, 이메일 등)와 서비스의 데이터가 생성된다. 이 데이터를 어딘가에 저장하고, 그 어딘가에서 클라이언트로 데이터를 받아와야 한다. 이곳이 바로 서버이다.

서버라고 해서 요청에 대한 응답만 하는 것은 아니다. 다른 서버에 요청을 보낼 수도 있다. 이 때는 요청을 보낸 서버가 클라이언트 역할을 한다.

정리하면, 서버는 클라이언트의 요청에 대해 응답을 한다. 응답으로 항상 Yes를 해야 하는 것은 아니고, No를 할 수도 있다. 만약 본인이 어떤 사이트로부터 차단당했다면 그 사이트의 서버는 본인의 요청에 대해 매번 No를 응답할 것이다.

노드는 자바스크립트 프로그램이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있다. 왜 다른 언어를 사용하지 않고 굳이 노드를 사용해 서버를 만들까? 이 궁금증을 해결하려면 먼저 노드의 특성을 알아야 한다. 공식 웹 사이트에 게시된 노드 소개글을 바탕으로 노드의 특성을 알아보자.

#### 1-1-2. 자바스크립트 런타임

공식 사이트에 게시된 노드 소개글을 다시 한 번 보자.

> Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다.

노드는 자바스크립트 런타임이다. 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻한다. 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있다. 쉽게 말해 노드는 자바스크립트 실행기라고 봐도 무방하다. 따라서 본인이 자바스크립트를 모른다면 노드를 전혀 활용할 수 없다.

기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행할 수 있었다. 브라우저는 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있다. 브라우저 외의 환경에서 자바스크립트를 실행하기 위한 여러 시도가 있었으나, 자바스크립트의 실행 속도 문제 때문에 모두 큰 호응을 얻지는 못했다.

하지만 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하자 이야기가 달라졌다. 당시 V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐고, 오픈 소스로 코드를 공개했다. 속도 문제가 해결되자 라이언 달(Ryan Dahl)은 2009년 V8 엔진 기반의 노드 프로젝트를 시작했다.

노드는 V8과 더불어 libuv라는 라이브러리를 사용한다. V8과 libuv는 `C`와 `C++`로 구현되어 있다. 본인이 코딩한 자바스크립트 코드는 노드가 알아서 V8과 libuv에 연결해주므로, 노드를 사용할 때 `C`와 `C++`은 몰라도 된다.

libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있다. 이 모델이 무엇이고 어떤 장단점들이 있는지 알아보자.

#### 1-1-3. 이벤트 기반

이벤트 기반(`event-driven`)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있다.

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해둬야 한다. 이를 이벤트 리스너(`event listener`)에 콜백(`callback`) 함수를 등록한다고 표현한다. 버튼을 클릭할 때 경고창을 띄우도록 설정하는 것을 예로 들어보자. 클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수를 등록해두면 클릭 이벤트가 발생할 때마다 콜백 함수가 실행되어 경고창이 뜨는 것이다.

노드도 이벤트 기반형식으로 동작하므로, 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출한다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, 노드는 다음 이벤트가 발생할 때까지 기다린다.

이벤트 기반 모델에서는 이벤트 루프(`event loop`)라는 개념이 등장한다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다.

특정 밀리초(1/1000초) 이후에 코드를 실행하는 `setTimeout`을 사용해 보자. 콘솔에 어떤 로그가 기록될지 예측해보자.

```js
run = () => {
  console.log("3초 후 실행");
};
console.log("시작");
setTimeout(run, 3000);
console.log("끝");
```

결과는 다음과 같다.

```
시작
끝
3초 후 실행
```

3초 뒤에 `run` 함수를 실행하는 코드이다. 콘솔 결과는 쉽게 예측할 수 있지만, 호출 스택으로 설명하기는 어렵다. `setTimeout` 함수의 콜백인 `run`이 호출 스택에 언제 들어가는지 지금까지 배운 내용으로는 쉽게 파악할 수 없기 때문이다. 이를 파악하기 위해서는 이벤트 루프, 태스크 큐(`task queue`), 백그라운드(`background`)를 알아야 한다. 다음은 기술적으로 정확히 설명하기보단 이해를 돕기 위해 추상화해서 설명한 내용이다.

- 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(`loop`)라고 부른다.

- 백그라운드: `setTimeout` 같은 타이머나 이벤트 리스너들이 대기하는 곳이다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 된다. 여러 작업이 동시에 실행될 수 있다.

- 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부른다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 한다.

위 코드가 실행되는 내부 과정을 보자.

먼저, 전역 컨텍스트인 `anonymous`가 호출 스택에 들어간다. 그 뒤 `setTimeout`이 호출 스택에 들어간다.

호출 스택에 들어간 순서와 반대로 실행되므로, `setTimeout`이 먼저 실행된다. `setTimeut`이 실행되면 타이머와 함께 `run` 콜백을 백그라운드로 보내고, `setTimeout`은 호출 스택에서 빠진다. 그다음으로 `anonymous`가 호출 스택에서 빠진다. 백그라운드에서는 3호를 센 후 `run` 함수를 태스크 큐로 보낸다. 3초를 셌다는 것은 백그라운드에 맡겨진 작업이 완료된 것으로 이해해도 된다. 이런 식으로 이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부른다.

이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행한다. 호출 스택으로 올려진 `run`은 실행되고, 실행 완료 후 호출 스택에서 비워진다. 이벤트 루프는 태스크 큐에 콜백 함수가 들어올 때까지 계속 대기한다.

만약 호출 스택에 함수들이 너무 많이 들어 있으면 3초가 지난 후에도 `run` 함수가 실행되지 않을 수 있다. 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 `run` 함수를 호출 스택으로 가져오기 때문이다. 이것이 `setTimeout`의 시간이 정확하지 않을 수도 있는 이유이다.

#### 1-1-4. 논 블로킹 I/O

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다. 작업에는 두 가지 종류가 있는데, 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이다. 기본적으로 각자가 작성한 자바스크립트 코드는 동시에 실행될 수 없다. 하지만 자바스크립트상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있다.

I/O는 입력(`input`)/출력(`output`)을 의미한다. 파일 시스템 접근(파일 읽기, 파일 쓰기, 폴더 만들기 등)이나 네트워크를 통한 요청 같은 작업이 I/O의 일종이다. 이러한 작업을 할 때 노드는 논 블로킹 방식으로 처리하는 방법을 제공한다. **논 블로킹**이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 **블로킹**은, 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 보통 블로킹 방식보다, 논 블로킹 방식이 같은 작업을 더 짧은 시간에 처리할 수 있다. 다만, 작업들이 모두 동시에 처리될 수 있는 작업이라는 전제가 있다.

노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 한다. 따라서 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다.

예를 들어 처리하는 데 1초가 걸리는 작업 다섯 개가 있다고 해 보자. 그 중 세 개는 동시에 처리할 수 있고 두 개는 동시에 처리할 수 없다. 각자를 나열하여 그 순서대로 작업하는 경우는 5초 정도가 소요될 것이고, 동시 처리가 가능한 세 개를 한꺼번에 처리하고 아닌 것들을 각각 병렬적으로 배치하면, 순서만 바꿨을 뿐인데 3초 정도로 작업 시간이 단축된다.

이렇게 작업 순서에 따라 성능이 크게 달라진다. 동시에 처리될 수 있는 I/O 작업이라도 논블로킹 방식으로 코딩하지 않으면 의미가 퇴색되므로 논 블로킹 방식으로 코딩하는 습관을 들여야 한다.

```js
longRunningTask = () => {
  // 오래 걸리는 작업
  console.log("작업 끝");
};

console.log("시작");
longRunningTask();
console.log("다음 작업");
```

작업을 수행하는 데 오래 걸리는 `longRunningTask` 함수가 있고, 이 함수가 블로킹 방식의 I/O 작업을 한다고 생각해 보자. 이 작업이 완료되기 전까지는 이어지는 `console.log("다음 작업");`이 호출되지 않는다.

이번에는 setTimeout을 사용해서 코드를 바꿔보자.

```js
longRunningTask = () => {
  // 오래 걸리는 작업
  console.log("작업 끝");
};
console.log("시작");
setTimeout(longRunningTask, 0);
console.log("다음 작업");
```

결과는 다음과 같다.

```
시작
다음 작업
작업 끝
```

`setTimeout(콜백, 0)`은 코드를 논 블로킹으로 만들기 위해 사용하는 기법 중 하나이다. 사실 노드에서는 `setTimeout(콜백, 0)` 대신 다른 방식을 주로 사용하긴 한다(3.4.3의 `setImmediate` 참조). 이벤트 루프를 이해했다면 `setTimeout`의 콜백 함수인 `longRunningTask`가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있다. 다음 작업이 먼저 실행된 이후, 오래 걸리는 작업이 완료된다.

다만, 아무리 논 블로킹 방식으로 코드를 작성하더라도 코드가 전부 각자가 작성한 것이라면 전체 소요 시간이 짧아지지는 않는다. 각자의 코드는 서로 동시에 실행되지 않기 때문이다. 단순히 실행 순서만 바뀔 뿐이다. 위 예제에서는 `console.log('다음 작업')`과 `longRunningTask` 모두 각자가 작성한 코드이다.

그렇다고 I/O 작업이 없다고 해서 논 블로킹이 의미가 없는 것은 아니다. 오래 걸리는 작업을 처리해야 하는 경우, 논 블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있다. 또한, **논 블로킹**과 **동시**가 같은 의미가 아니라는 것도 알아두자. 동시성은 동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있다.

> setTimtout(콜백, 0)에서, 밀리초를 0으로 설정했으므로 바로 실행되는 것으로 착각할 수 있다. 하지만, 브라우저와 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않는다. HTML5 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있다.

블로킹과 논 블로킹 외에 동기와 비동기라는 개념도 들어봤을 것이다. 동기와 비동기, 블로킹과 논 블로킹의 관계는 3.6.1에서 코드와 함께 설명한다. 노드에서는 동기와 블로킹이 유사하고 비동기와 논 블로킹이 유사하다고만 알아두면 된다.

#### 1-1-5. 싱글 스레드

이벤트 기반, 논 블로킹 모델과 더불어 노드를 설명할 때 자주 나오는 용어가 하나 더 있다. 바로 싱글 스레드이다. 싱글 스레드란 스레드가 하나뿐이라는 것을 의미한다. 각자가 작성한 자바스크립트 코드가 동시에 실행될 수 없는 이유이기도 하다. 스레드를 이해하기 위해서는 프로세스부터 알아야 한다. 프로세스와 스레드의 차이는 다음과 같다.

- 프로세스는 운영체제에서 할당하는 작업의 단위이다. 노드나 웹 브라우저와 같은 프로그램은 개별적인 프로세스이다. 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있다. 스레드들은 부모 프로세스의 자원을 공유한다. 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있다.

노드가 싱글 스레드라는 말을 들어봤을 것이다. 하지만 엄밀히 말하면 싱글 스레드로 동작하지는 않는다. 노드를 실행하면 먼저 프로세스가 하나 생성된다. 그리고 그 프로세스에서 스레드들을 생성하는데, 이때 내부적으로 스레드를 여러개 생성한다. 그중에서 각자가 직접 제어할 수 있는 스레드는 하나뿐이다. 그래서 흔히 노드가 싱글 스레드라고 여겨지는 것이다.

스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 하나의 스레드만 직접 조작할 수 있으므로 일손이 하나인 셈이다. 요청이 많이 들어오면 한 번에 하나씩 요청을 처리한다. 블로킹이 심하게 일어나는 작업을 처리하지만 않는다면 스레드 하나로도 충분하다. 블로킹이 발생할 것 같은 경우에는 논 블로킹 방법으로 대기 시간을 최대한 줄인다.

> **스레드풀과 워커 스레드**
>
> 노드가 싱글 스레드로 동작하지 않는 두 가지 경우가 있다. 하나는 스레드풀(`Thread Pool`)이고, 다른 하나는 워커 스레드(`Worker Thread`)이다.
>
> 스레드풀은 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용한다. 대표적인 예로 암호화(3.5.5), 파일 입출력(3.6), 압축(3.6.2) 등이 있다.
>
> 워커 스레드는 노드 12 버전에서 안정화된 기능으로 이제 노드에서도 멀티 스레드를 사용할 수 있게 되었다. 각자가 직접 다수의 스레드를 다룰 수 있다. CPU 작업(연산이 많은 작업)이 많은 경우 워커 스레드를 사용하면 된다.

언뜻 보면 여러 개의 일을 동시에 처리할 수 있으므로 멀티 스레드가 싱글 스레드보다 좋아보인다. 하지만 꼭 그런 것은 아니다. 이해를 돕기 위해 하나의 예시를 들어 보겠다.

한 음식점에 점원이 한 명 있다. 손님은 여러 명이다. 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 한다. 그 후 다음 손님의 주문을 받는다. 이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못하고 기다려야 한다. 이것이 바로 싱글 스레드(점원), 블로킹 모델이다. 매우 비효율적이다.

이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받는다. 요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 사실만 주방에 계속 알려주는 것이다. 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙한다. 요리의 특성(블로킹인지 논 블로킹인지)에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서는 일치하지 않을 수도 있다.

이것이 싱글 스레드, 논 블로킹 모델이다. 바로 노드가 채택하고 있는 방식이다. 점원은 한 명이지만 혼자서 많은 일을 처리할 수 있다. 하지만 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가 생길 수 있다. 또한, 요리를 하는 데 시간이 오래 걸린다면(CPU를 많이 쓰는 작업) 주문이 많이 들어왔을 때 버거울 수 있다.

멀티 스레드 방식에서는 손님 한 명이 올 때마다 점원도 한 명씩 붙어 주문을 받고 서빙한다. 언뜻 보면 싱글 스레드보다 좋은 방법인 것 같지만, 장단점이 있다. 일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없다. 점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문이다. 하지만 손님의 수가 늘어날수록 점원의 수도 늘어난다. 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다는 것도 문제가 된다. 점원을 새로 고용하거나 기존 점원을 해고하는 데는 비용이 발생한다.

그렇다면 점원 여러 명(멀티 스레드)이 모두 논 블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 의문이 들 수 있다. 실제로 그렇다. 다만 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어려우므로 멀티 프로세싱 방식을 대신 사용한다. I/O 요청에는 멀티 프로세싱이 더 효율적이기도 하다.

| 멀티 스레딩                                  | 멀티 프로세싱            |
| -------------------------------------------- | ------------------------ |
| 하나의 프로세스 안에서 여러 개의 스레드 사용 | 여러 개의 프로세스 사용  |
| CPU 작업이 많을 때 사용                      | I/O 요청이 많을 때 사용  |
| 프로그래밍이 어려움                          | 프로그래밍이 비교적 쉬움 |

I/O 작업을 처리할 때는 멀티 스레딩보다 멀티 프로세싱이 효율적이므로 노드는 멀티 프로세싱을 많이 한다. 4.5의 cluser 모듈과 15.1.5의 pm2 패키지에서 멀티 프로세싱을 가능하게 하는 방법을 알아본다. 멀티 스레딩을 하는 방법은 3.5.7에서 알아본다.

### 1-2. 서버로서의 노드

이 절에서는 노드를 서버로 사용할 때의 특성과 장단점을 알아볼 것이다.

노드는 기본적으로 싱글 스레드, 논 블로킹 모델을 사용하므로(자바스크립트 언어의 특성이기도 하다) 노드 서버 또한 동일한 모델일 수밖에 없다. 따라서 노드 서버의 장단점은 싱글 스레드, 논 블로킹 모델의 장단점과 크게 다르지 않다.

서버에는 기본적으로 I/O 요청이 많이 발생하므로, I/O 처리를 잘하는 노드를 서버로 사용하면 좋다. 노드는 (논 블로킹 방식으로 코드를 작성했다는 가정 하에) libuv 라이브러리를 사용하며 I/O 작업을 논 블로킹 방식으로 처리한다. 따라서 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있다. 하지만 노드는 CPU 부하가 큰 직업에는 적합하지 않다. 각자가 작성하는 코드는 모두 스레드 하나에서 처리된다. 코드가 CPU 연산을 많이 요구하면 스레드 하나가 혼자서 감당하기 어렵다.

이와 같은 특성을 활용하려면 노드를 어디에 사용해야 할까? 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 실시간 채팅 어플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.

노드 12 버전에서 워커 스레드 기능의 안정화로 멀티 스레드 작업을 할 수 있게 되었지만, 멀티 스레드 프로그래밍을 하는 것은 싱글 스레드에 비해 어렵다. 특히 스레드가 작업을 나눠서 처리할 수 있게 직접 나눠주는 것이 그렇다. 또한, 멀티 스레드 프로그래밍을 하더라도 `C`, `C++`, `Rust`, `Go`와 같은 언어에 비해 속도가 많이 느리다.

따라서 멀티 스레드 기능이 있다고 하더라도 이미지나 비디오 처리, 혹은 대규모 데이터 처리처럼 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않는다. 노드보다 더 적합한 다른 언어 서버가 많다. 그럼에도 굳이 노드로 하고 싶다면, 요즘은 AWS 람다(AWS Lambda)나 구글 클라우드 펑션스(Google Cloud Functions) 같은 서비스에서 노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원하므로 고려해봐야 한다. 싱글 스레드 방식의 프로그래밍은 멀티 스레드 방식보다 상대적으로 쉬우므로 서버 프로그래밍에 익숙하지 않은 사람도 쉽게 입문할 수 있다. 다만 싱글 스레드 방식으로 서버를 운영할 때는 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 한다. 에러를 제대로 처리하지 못하면 하나뿐인 스레드가 죽어버려서 서버 전체가 멈추기 때문이다.

노드에는 웹 서버가 내장되어 있어 입문자가 쉽게 접근할 수 있다. 노드 외의 서버를 개발하다 보면 아파치(Apache), nginx, IIS처럼 별도의 웹 서버를 설치해야 하는 경우가 많다. 심지어 톰캣(Tomcat)같은 웹 어플리케이션 서버(WAS)를 추가로 설치하는 경우도 있다. 이 경우에는 프로그래밍 외에도 웹 서버와 WAS 사용을 익혀야 한다. 하지만 노드는 내장된 웹 서버를 사용하면 되므로 편리하다. 하지만 나중에 서버 규모가 커지면 결국 nginx 등의 웹 서버를 노드 서버와 연결해야만 한다.

노드 사용자들이 말하는 가장 큰 장점은 언어로 자바스크립트를 사용한다는 것이다. 웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있다. 이로써 개발 생산성을 획기적으로 높였고, 생산성이 중요한 기업이 노드를 채택하는 이유가 되었다.

노드는 생산성은 매우 좋지만, `Go`처럼 비동기에 강점을 보이는 언어나 nginx처럼 정적 파일 제공, 로드 밸런싱에 특화된 웹 서버에 비해서는 속도가 느리다. 그렇긴 해도 극단적인 성능이 필요하지 않다면 이러한 단점은 노드의 생산성으로 어느 정도 극복할 수 있다.

자바스크립트를 사용함으로써 얻을 수 있는 소소한 장점도 있다. 요즘은 XML 대신 JSON을 사용해서 데이터를 주고받는데, JSON이 자바스크립트 형식이므로 노드에서는 쉽게 처리할 수 있다.

> 노드의 장단점

| 장점                                          | 단점                                              |
| --------------------------------------------- | ------------------------------------------------- |
| 멀티 스레드 방식에 비해 적은 컴퓨터 자원 사용 | 기본적으로 싱글 스레드라서 CPU 코어를 하나만 사용 |
| I/O 작업이 많은 서버로 적합                   | CPU 작업이 많은 서버로는 부적합                   |
| 멀티 스레드 방식보다 쉬움                     | 하나뿐인 스레드가 멈추지 않도록 관리가 필요함     |
| 웹 서버가 내장되어 있음                       | 서버 규모가 커졌을 때 서버를 관리하기 어려움      |
| 자바스크립트를 사용함                         | 어중간한 성능                                     |
| JSON 형식과 쉽게 호환됨                       |                                                   |

웹 사이트 중에는 쇼핑몰, 블로그 같은 사이트도 많다. 이러한 사이트들은 정적인 컨텐츠를 많이 제공한다. 이들에게도 노드 서버가 적합할까? 이런 사이트는 보통 기본적인 틀이 있고, 그 안에 내용물(텍스트, 이미지)만 조금씩 달라진다. 노드가 다른 서버에 비해 이러한 컨텐츠를 제공하는 데 뚜렷한 장점을 가지지는 않는다. 하지만 그렇다고 적합하지 않다는 것도 아니다. 넌적스(Nunjucks), 퍼그(Pug), EJS 같은 템플릿 엔진을 통해 다른 언어와 비슷하게 컨텐츠를 제공할 수 있다. 템플릿 엔진은 6.5에서 다룬다.

안정성과 보안성 측면의 문제도 이미 충분히 검증되었다. 규모가 큰 곳을 꼽자면 미국항공우주국(NASA), 에어비앤비, 우버, 넷플릭스, 링크드인 등에서 노드를 사용하고 있다. 페이팔, 월마트, 이베이와 같이 결제 시스템을 사용하는 대기업들도 노드로 서비스를 운영한다. 국내에서도 네이버, 카카오, 위메프, 야놀자 같은 기업들이 노드를 사용한다.

### 1-3. 서버 외의 노드

처음에는 노드를 대부분 서버로 사용했지만, 노드는 자바스크립트 런타임이므로 용도가 서버에만 한정되지 않는다. 사용 범위가 점점 늘어나서 노드는 웹, 모바일, 데스크탑 어플리케이션 개발에도 사용되기 시작했다.

노드 기반으로 돌아가는 대표적인 웹 프레임워크로는 앵귤러(Angular.js), 리액트(React), 뷰(Vue.js) 등이 있다. 앵귤러는 구글 진영에서 프론트엔드 앱을 만들 때 주로 사용하고, 리액트는 페이스북 진영에서 주로 사용한다. 모바일 개발 도구로는 리액트 네이티브(React Native)를 많이 사용한다. 페이스북, 인스타그램, 핀터레스트, 월마트, 테슬라 등이 리액트 네이티브를 사용하여 모바일 앱을 운영 중이다. 데스크탑 개발 도구로는 일렉트론(electron)이 대표적이다. 일렉트론으로 만들어진 프로그램으로는 Atom, Slack, Discord 등이 있다. VSCode 또한 일렉트론으로 만들어졌다.

### 1-5. 함께 보면 좋은 자료

- 노드 공식 사이트: https://nodejs.org/ko
- 노드 공식 사이트의 가이드: https://nodejs.org/ko/docs/guides/
- 노드에 대한 전반적인 설명: https://nodejs.dev/
- 이벤트 루프 설명: https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/
- 이벤트 루프에 대한 시각적 설명: http://latentflip.com/loupe
- VS Code 공식 사이트: https://code.visualstudio.com/
- Homebrew 사이트: https://brew.sh/index_ko

## 2. 알아두어야 할 자바스크립트

자바스크립트는 매년 새로운 버전으로 업데이트된다. 노드도 주기적(6개월마다)으로 버전을 올리며 변경된 자바스크립트 문법을 반영하고 있다. 앞으로의 예제들은 ES2015+ 문법을 사용하므로 2.1에서는 새로운 문법을 간단히 알아보고 2.2에서는 서버와 통신하기 위해 프런트엔드에서 사용하는 자바스크립트 코드를 알아볼 것이다.

### 2-1. ES2015+

2015년 자바스크립트 문법에 매우 큰 변화가 있었다. 바로 ES2015(=ES6)가 등장한 것이다. 2015년을 기점으로 매년 문법 변경 사항이 발표되고 있으며, 새로운 문법 상세(specification)에 대해서도 활발한 논의가 이루어지고 있다. 2020년 현재 ES2020까지 나왔다. 인터넷 익스플로러와 같은 구형 브라우저에서는 최신 문법을 사용할 수 없지만, 요즘에는 babel처럼 구형 브라우저에 맞게 문법을 변환해주는 도구가 널리 쓰이므로 큰 문제가 되지 않는다. 이제는 ES2015 이상의 자바스크립트 문법을 배울 때이다. 다른 언어들의 장점을 본딴 편리한 기능이 많이 추가되었기 때문이다. 노드 6 버전부터 ES2015 문법을 사용할 수 있다. 이 책에서는 ES2015 이상의 자바스크립트를 통틀어 ES2015+라고 표현할 것이다.

**만약 자바스크립트 최신 문법을 알지 못한다면, 이 책을 읽을 때 많은 문제가 있을 수 있다.** 하지만 잘 모르더라도 이 기회에 자바스크립트 문법을 같이 공부하는 것을 추천한다. 실무에서는 대부분 최신 문법을 사용하여 코드를 작성하고 있다. 혹시 자바스크립트 자체를 처음 접했다면, 자바스크립트 기본 문법부터 익혀야 한다. 노드는 자바스크립트 실행기이므로 자바스크립트 문법을 모른다면 실행할 것이 없다.

ES2015+의 문법 변경 사항이 생소한 독자들을 위해 이번 장에서는 이 책에서 사용하는 최신 문법을 간단하게 알아본다. 또한, 프런트엔드 환경에서 브라우저가 제공하는 몇 가지 객체를 사용하니 그에 대해서도 알아볼 것이다.

#### 2-1-1. const, let

보통 자바스크립트를 배울 때는 var로 변수를 선언하는 방법부터 배운다. 하지만 var은 이제 const와 let이 대체합니다. 먼저 const와 let이 공통적으로 가지는 특징인 블록 스코프(범위)에 대해 알아보자.

```js
if (true) {
  var x = 3;
}
console.log(x); // 3

if (true) {
  const y = 3;
}
console.log(y); // Uncaught ReferenceError: y is not defined
```

x는 정상적으로 출력되는데 y는 에러가 발생한다. var을 const로 바꿨을 뿐인데 차이가 발생하는 것이다. var은 함수 스코프를 가지므로 if문의 블록과 관계없이 접근할 수 있다. 하지만 const와 let은 블록 스코프를 가지므로 블록 밖에서는 변수에 접근할 수 없다. 블록의 범위는 if, while, for, function 등에서 볼 수 있는 중괄호({와 } 사이)이다. 함수 스코프 대신 블록 스코프를 사용함으로써 호이스팅 같은 문제도 해결되고 코드 관리도 수월해졌다.

const, let과 var은 스코프 종류가 다르다. 그렇다면 const와 let 간의 차이는 무엇일까? const는 한 번 값을 할당하면 다른 값을 할당할 수 없다. 다른 값을 할당하려고 하면 에러가 발생한다. 또한, 초기화할 때 값을 할당하지 않으면 에러가 발생한다. 따라서 const로 선언한 변수를 상수라고 부르기도 한다.

```js
const a = 0;
a = 1; // Uncaught TypeError: Assignment to constant variable.

let b = 0;
b = 1; // 1

const c; // Uncaught SyntaxError: Missing initializer in const declaration
```

#### 2-1-3. 객체 리터럴

객체 리터럴에 편리한 기능이 추가되었다. 다음 코드는 `oldObject` 객체에 동적으로 속성을 추가하고 있다.

```js
var sayNode = function() {
  console.log('Node');
};
var es = 'ES';
var oldObject = {
  say JS: function() {
    console.log("JS");
  },
  sayNode: sayNode,
};

oldObject[es + 6] = 'Fantastic';
oldObject.sayNode(); // Node
oldObject.sayJS(); // JS
console.log(oldObject.ES6); // Fantastic
```

위 코드는 아래와 같이 다시 쓸 수 있다.

```js
const newObject = {
  sayJS() {
    console.log("JS");
  },
  sayNode,
  [es + 6]: "Fantastic",
};

newObject.sayNode(); // Node
newObject.sayJS(); // JS
console.log(newObject.ES6); // Fantastic
```

`sayJS` 같은 객체의 메소드에 함수를 연결할 때 더는 콜론(:)과 function을 붙이지 않아도 된다.

`sayNode: sayNode` 처럼 속성명과 변수명이 동일한 경우에는 한 번만 써도 되게 바뀌었다. 자바스크립트에서 다음과 같은 경우가 많이 나오는데, 이때 코드의 중복을 피할 수 있어서 편리하다.

```js
{ name: name, age: age } // ES5
{ name, age } // ES6
```

객체의 속성명은 동적으로 생성할 수 있다. 예전 문법에서는 ES6라는 속성명을 만들려면 객체 리터럴(`oldObject`) 바깥에서 [es + 6]를 해야 했다. 하지만 ES2015 문법에서는 객체 리터럴 안에 동적 속성을 선언해도 된다. `newObject` 안에서 [es + 6]가 속성명으로 바로 사용되고 있다.

객체 리터럴에 추가된 문법은 코딩할 때의 편의를 위해 만들어진 것이라는 느낌이 강하다. 익숙해지면 코드의 양을 많이 줄일 수 있다.

### 2-1-5. 구조분해 할당

구조분해 할당을 사용하면 객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있다.

다음은 객체의 속성을 같은 이름의 변수에 대입하는 코드이다.

```js
var candyMachine = {
  status: {
    name: "node",
    count: 5,
  },
  getCandy: function () {
    this.status.count--;
    return this.status.count;
  },
};
var getCandy = candyMachine.getCandy;
var count = candyMachine.status.count;
```

이 코드를 아래와 같이 바꿀 수 있다.

```js
const candyMachine = {
  status: {
    name: "node",
    count: 5,
  },
  getCandy() {
    this.status.count--;
    return this.status.count;
  },
};

const {
  getCandy,
  status: { count },
} = candyMachine;
```

이 코드의 문법 또한 유효한 문법이다. `candyMachine` 객체 안의 속성을 찾아서 변수와 매칭한다. count처럼 여러 단계 안의 속성도 찾을 수 있다. `getCandy`와 count`변수가 초기화된 것이다. 다만, 구조분해 할당을 사용하면 함수의 this가 달라질 수 있다.`getCandy` 함수를 사용해 보자. 달라진 this를 원래대로 바꿔주려면 bind함수를 따로 사용해야 한다.

배열에 대한 구조분해 할당 문법도 존재한다.

```js
var array = ["nodejs", {}, 10, true];
var node = array[0];
var obj = array[1];
var bool = array[3];
```

array란 배열의 첫 번째, 두 번째 요소와 네 번째 요소를 변수에 대입하는 코드이다.

다음과 같이 바꿀 수 있다.

```js
const array = ["nodejs", {}, 10, true];
const [node, obj, bool] = array;
```

어색해 보이지만, 나름대로의 규칙이 있다. node, obj, bool의 위치를 보면 node는 배열의 첫 번째 요소, obj는 두 번째 요소, bool은 네 번째 요소라는 것을 알 수 있다. obj와 bool 사이의 요소인 10에는 변수명을 지어주지 않았으므로 10은 무시한다.

구조분해 할당 문법도 코드 줄 수를 상당히 줄여주므로 유용하다. 특히 노드는 모듈 시스템을 사용하므로 이러한 방식을 자주 쓴다. 모듈 시스템은 3.3에서 알아본다.

#### 2-1-6. 클래스

클래스 문법도 추가되었다. 하지만 다른 언어처럼 클래스 기반으로 동작하는 것이 아니라 여전히 프로토타입 기반으로 동작한다. 프로토타입 기반 문법을 보기 좋게 클래스로 바꾼 것이라고 이해하면 된다.

다음은 프로토타입 상속 예제 코드이다.

```js
var Human = function (type) {
  this.type = type || "human";
};

Human.isHuman = function (human) {
  return human instanceof Human;
};

Human.prototype.breathe = function () {
  alert("h-a-a-a-m");
};

var Zero = function (type, firstName, lastName) {
  Human.apply(this, arguments);
  this.firstName = firstName;
  this.lastName = lastName;
};

Zero.prototype = Object.create(Human.prototype);
Zero.prototype.constructor = Zero; // 상속하는 부분
Zero.prototype.sayName = function () {
  alert(this.firstName + " " + this.lastName);
};

var oldZero = new Zero("human", "Zero", "Cho");
Human.isHuman(oldZero); // true
```

Human 생성자 함수가 있고, 그 함수를 Zero 생성자 함수가 상속한다. Zero 생성자 함수를 보면 상속받기 위한 코드가 상당히 난해하다는 것을 알 수 있다. `Human.apply`와 `Object.create` 부분이 상속받는 부분이다.

위 코드를 클래스 기반으로 바꿔보자.

```js
class Human {
  constructor(type = "human") {
    this.type = type;
  }

  static isHuman(human) {
    return human instanceof Human;
  }

  breathe() {
    alert("h-a-a-a-m");
  }
}
class Zero extends Human {
  constructor(type, firstName, lastName) {
    super(type);
    this.firstName = firstName;
    this.lastName = lastName;
  }
  sayName() {
    super.breathe();
    alert(`${this.firstName}${this.lastName}`);
  }
}

const newZero = new Zero("human", "Zero", "Cho");
Human.isHuman(newZero); // true
```

전반적으로 class 안으로 그룹화된 것을 볼 수 있다. 생성자 함수는 constructor 안으로 들어갔고, `Human.isHuman` 같은 클래스 함수는 static 키워드로 전환되었다. 프로토타입 함수들도 모두 class 블록 안에 포함되어 어떤 함수가 어떤 클래스 소속인지 보기 쉽다. 상속도 간단해져서 extends 키워드로 쉽게 상속 가능하다. 다만, 이렇게 클래스 문법으로 바뀌었더라도 자바스크립트는 프로토타입 기반으로 동작한다는 것을 명심해야 한다.

#### 2-1-7. 프로미스

자바스크립트와 노드에서는 주로 비동기를 접한다. 특히 이벤트 리스너를 사용할 때 콜백 함수를 자주 사용한다. ES2015부터는 자바스크립트와 노드의 API들이 콜백 대신 프로미스(Promise) 기반으로 재구성되며, 악명 높은 콜백 지옥 현상을 극복했다는 평가를 받고 있따. 프로미스는 반드시 알아둬야 하는 객체이므로 여기뿐만 아니라 다른 자료들을 참고해서라도 반드시 숙지해야 한다.

프로미스는 다음과 같은 규칙이 있다. 먼저 프로미스 객체를 생성해야 한다.

```js
const condition = true; // true면 resolve, false면 reject
const promise = new Promise((resolve, reject) => {
  if (condition) {
    resolve("성공");
  } else {
    reject("실패");
  }
});
// 다른 코드가 들어갈 수 있음
promise
  .then((message) => {
    console.log(message); // 성공(resolve)한 경우 실행
  })
  .catch((error) => {
    console.error(error); // 실패(eject)한 경우 실행
  })
  .finally(() => {
    // 끝나고 무조건 실행
    console.log("무조건");
  });
```

`new Promise`로 프로미스를 생성할 수 있으며, 그 내부에 resolve와 reject를 매개변수로 갖는 콜백 함수를 넣는다. 이렇게 만든 promise 변수에 then과 catch 메소드를 붙일 수 있다. 프로미스 내부에서 resolve가 호출되면 then이 실행되고, reject가 호출되면 catch가 실행된다. finally 부분은 성공/실패 여부와 상관없이 실행된다.

resolve와 reject에 넣어준 인수는 각각 then과 catch의 매개변수에서 받을 수 있다. 즉 `resolve('성공')`이 호출되면 then의 message가 '성공'이 된다. 만약 `reject('실패')`가 호출되면 catch의 error가 '실패'가 되는 것이다. condition 변수를 false로 바꿔보면 catch에서 에러가 로깅된다.

프로미스를 쉽게 설명하자면, 실행은 바로 하되 결괏값은 나중에 받는 객체이다. 결괏값은 실행이 완료된 후 then이나 catch 메소드를 통해 받는다. 위 예제에서는 new Promise와 promise, then 사이에 다른 코드가 들어갈 수도 있다. new Promise는 바로 실행되지만, 결괏값은 then을 붙였을 때 받게 된다.

then이나 catch에서 다시 다른 then이나 catch를 붙일 수 있다. 이전 then의 return 값을 다음 then의 매개변수로 넘긴다. 프로미스를 return한 경우에는 프로미스가 수행된 후 다음 then이나 catch가 호출된다.

```js
promise
  .then((message) => {
    return new Promise((resolve, reject) => {
      resolve(message);
    });
  })
  .then((message2) => {
    console.log(message2);
    return new Promise((resolve, reject) => {
      resolve(message2);
    });
  })
  .then((message3) => {
    console.log(message3);
  });
  .catch((error) => {
    console.log(error);
  });
```

처음 then에서 message를 resolve하면 다음 then에서 message2로 받을 수 있다. 여기서 다시 message2를 resolve한 것을 다음 then에서 message3으로 받았다. 단 then에서 new Promise를 return해야 다음 then에서 받을 수 있다는 것을 기억해야 한다.

이것을 활용해서 콜백을 프로미스로 바꿀 수 있다. 다음은 콜백을 쓰는 패턴 중 하나이다. 이를 프로미스로 바꿔보자.

```js
function findAndSaveUser(Users) {
  Users.findOne({}, (err, user) => {
    // 첫번째 콜백
    if (err) {
      return console.error(err);
    }
    user.name = "zero";
    user.save((err) => {
      // 두번째 콜백
      if (err) {
        return console.error(err);
      }
      Users.findOne({ gender: "m" }, (err, user) => {
        // 생략
      });
    });
  });
}
```

콜백 함수가 세 번 중첩되어 있다. 콜백 함수가 나올 때마다 코드의 깊이가 깊어진다. 각 콜백 함수마다 에러도 따로 처리해줘야 한다. 이 코드를 다음과 같이 바꿀 수 있다.

```js
function findAndSaveUser(Users) {
  Users.findOne({})
    .then((user) => {
      user.name = "zero";
      return user.save();
    })
    .then((user) => {
      return Users.findOne({ gender: "m" });
    })
    .then((user) => {
      // 생략
    })
    .catch((err) => {
      console.error(err);
    });
}
```

코드의 깊이가 세 단계 이상 깊어지지 않는다. 위 코드에서 `then` 메소드들은 순차적으로 실행된다. 콜백에서 매번 따로 처리해야 했던 에러도 마지막 catch에서 한 번에 처리할 수 있다. 하지만 모든 콜백 함수를 위와 같이 바꿀 수 있는 것은 아니다. 메소드가 프로미스 방식을 지원해야 한다.

예제의 코드는 findOne과 save 메소드가 내부적으로 프로미스 객체를 갖고 있다고 가정했기에 가능하다. (`new Promise`가 함수 내부에 구현되어 있어야 한다). 지원하지 않는 경우 콜백 함수를 프로미스로 바꿀 수 있는 방법은 3.5.6에 나와 있다.

프로미스 여러 개를 한 번에 실행할 수 있는 방법이 있다. 기존의 콜백 패턴이었다면 콜백을 여러 번 중첩해서 사용해야 했을 것이다. 하지만 `Promise.all`을 활용하면 간단히 할 수 있다.

```js
const promise1 = Promise.resolve("성공1");
const promise2 = Promise.resolve("성공2");
Promise.all([promise1, promise2])
  .then((result) => {
    console.log(result); // ['성공1', '성공2'];
  })
  .catch((error) => {
    console.error(error);
  });
```

`Promise.resolve`는 즉시 resolve하는 프로미스를 만드는 방법이다. 비슷한 것으로 즉시 reject하는 Promise.reject도 있다. 프로미스가 여러 개 있을 때 `Promise.all`에 넣으면 모두 resolve될 때까지 기다렸다가 then으로 넘어간다. result 매개변수에 각각의 프로미스 결괏값이 배열로 들어 있다. Promise 중 하나라도 reject가 되면 catch로 넘어간다.

#### 2-1-8. async/await

노드 7.6 버전부터 지원되는 기능이다. ES2017에서 추가되었으며, 알아두면 정말 편리한 기능이다. 특히 노드처럼 비동기 위주로 프로그래밍을 해야 할 때 도움이 많이 된다.

프로미스가 콜백 지옥을 해결했다지만, 여전히 코드가 장황하다. then과 catch가 계속 반복되기 때문이다. async/await 문법은 프로미스를 사용한 코드를 한 번 더 깔끔하게 줄인다.

2-1-7의 프로미스 코드를 다시 보자.

```js
function findAndSaveUser(Users) {
  Users.findOne({})
    .then((user) => {
      user.name = "zero";
      return user.save();
    })
    .then((user) => {
      return Users.findOne({ gender: "m" });
    })
    .then((user) => {
      // 생략
    })
    .catch((err) => {
      console.error(err);
    });
}
```

콜백과 다르게 코드의 깊이가 깊어지지는 않지만, 코드는 여전히 길다. async/await 문법을 사용하면 다음과 같이 바꿀 수 있다. async function이라는 것이 추가되었다.

```js
async fucntion findAndSaveUser(Users) {
  let user = await.Users.findOne({});
  user.name = 'zero';
  user = await user.save();
  user = await Users.findOne({gender: 'm'});
  // 생략
}
```

놀라울 정도로 코드가 짧아졌다. 함수 선언부를 일반 함수 대신 `async function`으로 교체한 후, 프로미스 앞에 await을 붙였다. 이제 함수는 해당 프로미스가 resolve될 때까지 기다린 뒤 다음 로직으로 넘어간다. 예를 들면 `await Users.findOne({})`이 resolve될 때까지 기다린 다음에 user 변수를 초기화하는 것이다.

위 코드는 에러를 처리하는 부분(프로미스가 reject된 경우)이 없으므로 다음과 같은 추가 작업이 필요하다.

```js
async function findAndSaveUser(Users) {
  try {
    let user = await Users.findOne({});
    user.name = "zero";
    user = await user.save();
    user = await Users.findOne({ gender: "m" });
    // 생략
  } catch (error) {
    console.log(error);
  }
}
```
